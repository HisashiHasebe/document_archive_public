"use strict";(self.webpackChunkkurokuro=self.webpackChunkkurokuro||[]).push([[44315],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(n),d=r,h=p["".concat(c,".").concat(d)]||p[d]||m[d]||a;return n?i.createElement(h,o(o({ref:t},u),{},{components:n})):i.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<a;l++)o[l]=n[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},19248:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var i=n(87462),r=(n(67294),n(3905));const a={date:new Date("2022-04-08T00:00:00.000Z"),title:"Common Patterns for Microservices",description:"Common Patterns Found Within Microservices Architecture",slug:"common-patterns-for-microservices",authors:"diverta",hide_table_of_contents:!1},o=void 0,s={permalink:"/blog/common-patterns-for-microservices",source:"@site/blog/common-patterns-for-microservices.md",title:"Common Patterns for Microservices",description:"Common Patterns Found Within Microservices Architecture",date:"2022-04-08T00:00:00.000Z",formattedDate:"April 8, 2022",tags:[],readingTime:5.975,hasTruncateMarker:!0,authors:[{name:"Diverta",title:"Creator of Kuroco service",url:"https://www.diverta.co.jp",imageURL:"https://github.com/diverta.png",key:"diverta"}],frontMatter:{date:"2022-04-08T00:00:00.000Z",title:"Common Patterns for Microservices",description:"Common Patterns Found Within Microservices Architecture",slug:"common-patterns-for-microservices",authors:"diverta",hide_table_of_contents:!1},prevItem:{title:"API Management",permalink:"/blog/api-management"},nextItem:{title:"Headless CMS for Jamstack",permalink:"/blog/headless-cms-for-jamstack"}},c={authorsImageUrls:[void 0]},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Direct Client-to-Microservice Communication",id:"direct-client-to-microservice-communication",level:2},{value:"The API Gateway Pattern",id:"the-api-gateway-pattern",level:2},{value:"API Gateway",id:"api-gateway",level:2},{value:"Requests aggregation",id:"requests-aggregation",level:3},{value:"Gateway Offloading",id:"gateway-offloading",level:2},{value:"Backend for Frontend (BFF)",id:"backend-for-frontend-bff",level:2},{value:"Kuroco API Management",id:"kuroco-api-management",level:2}],u={toc:l},p="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Common Patterns Found Within Microservices Architecture"),(0,r.kt)("h2",{id:"table-of-contents"},"Table of Contents"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Overview"),(0,r.kt)("li",{parentName:"ul"},"Direct Client-to-Microservice Communication"),(0,r.kt)("li",{parentName:"ul"},"The API Gateway Pattern"),(0,r.kt)("li",{parentName:"ul"},"Gateway Offloading"),(0,r.kt)("li",{parentName:"ul"},"Backend for Frontend (BFF)"),(0,r.kt)("li",{parentName:"ul"},"Kuroco API Management")),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Microservices are a type of application architecture that break down an application into multiple service components, in contrast with a traditional monolithic architecture where all the parts are bound together, and sharing dependencies."),(0,r.kt)("p",null,"A microservice exposes fine-grained endpoints, which function independently of other microservices.  The goal is to make each service simpler to build and maintain, reduce dependencies, and increase the speed and scalability of the microservices.  As applications grow in complexity, communicating with many bundled microservices can cause issues, which are discussed below."),(0,r.kt)("h2",{id:"direct-client-to-microservice-communication"},"Direct Client-to-Microservice Communication"),(0,r.kt)("p",null,"The most basic pattern is direct client-to-microservice architecture. In this pattern, a client application makes direct requests to the microservices."),(0,r.kt)("p",null,"Larger server-side applications are typically organized as a cluster, with load balancing required to manage requests from the client to the proper backend microservices.  As the application grows, this can become more difficult to manage, as the number of microservice types it uses may number in the dozens."),(0,r.kt)("p",null,"It is therefore important for larger applications to minimize the number of requests to backend microservices, as this can increase latency and result in poor performance on the frontend UI side.  Rather, responses should be bundled on the server side and served to frontend when the required data is aggregated."),(0,r.kt)("p",null,"The other major issue with the direct client-to-microservices pattern is handling functionality like authorization, transforming of data, and dispatching dynamic requests."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If authorization is required for every microservice individually, this can create a lot of development overhead and repeated code, which is difficult to manage at scale."),(0,r.kt)("li",{parentName:"ul"},"If microservices are using protocols not meant for Internet clients to consume directly, they must first be converted to HTTP/HTTPS, which can also require a lot of development overhead."),(0,r.kt)("li",{parentName:"ul"},"Bundling API microservices to meet the specific needs of different frontends, like mobile apps versus web browsers")),(0,r.kt)("h2",{id:"the-api-gateway-pattern"},"The API Gateway Pattern"),(0,r.kt)("p",null,"In the above pattern, client applications would become coupled with many microservice endpoints over time.  If the application were to change its structure or introduce new microservices, it would quickly become unwieldy to handle so many endpoints."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Coupling:  Although microservices are independent of each other, client applications often make direct reference to internal microservices, which can cause breaking changes if the internal microservices are refactored."),(0,r.kt)("li",{parentName:"ul"},"Latency: If any of the client application\u2019s views require many calls to multiple services, this can bog down the network and greatly increase latency. Aggregation is the most obvious solution for this."),(0,r.kt)("li",{parentName:"ul"},"Security: Microservices are publicly available by default, making the attack surface larger than if internal microservices not directly used by the client apps are hidden. "),(0,r.kt)("li",{parentName:"ul"},"Authorization: Publicly available microservice each need to handle cross-cutting concerns such as authorization and SSL. This results in development overhead and repeated code for each microservice, which could be consolidated.")),(0,r.kt)("p",null,"The most widely used solution for the above issues is an API Gateway."),(0,r.kt)("h2",{id:"api-gateway"},"API Gateway"),(0,r.kt)("p",null,"The API Gateway pattern is about placing the needs of the client app first.  It sits between the client application and the microservices, acting as a reverse proxy, routing requests from clients to services. It can also handle functionality like authentication, SSL termination, and caching."),(0,r.kt)("p",null,"An API Gateway can offer various features, including reverse proxy or gateway routing, to redirect or route requests to the endpoints of the internal microservices. The gateway provides a single endpoint or URL for the client applications, internally mapping the requests to a group of internal microservices. This routing feature helps to decouple the client apps from the microservices but it's also convenient when modernizing a monolithic API by sitting the API Gateway in between the monolithic API and the client apps, then you can add new APIs as new microservices while still using the legacy monolithic API until it's split into many microservices in the future. "),(0,r.kt)("p",null,"Because of the API Gateway, the client apps won't notice if the APIs being used are implemented as internal microservices or a monolithic API and more importantly, when evolving and refactoring the monolithic API into microservices, thanks to the API Gateway routing, client apps won't be impacted with any URI change."),(0,r.kt)("h3",{id:"requests-aggregation"},"Requests aggregation"),(0,r.kt)("p",null,"As part of the gateway pattern you can aggregate multiple client requests (usually HTTP requests) targeting multiple internal microservices into a single client request. This pattern is especially convenient when a client page/screen needs information from several microservices. With this approach, the client app sends a single request to the API Gateway that dispatches several requests to the internal microservices and then aggregates the results and sends everything back to the client app. "),(0,r.kt)("p",null,"The main benefit and goal of this design pattern is to reduce chattiness between the client apps and the backend API, which is especially important for remote apps, like mobile apps or requests coming from SPA apps that come from JavaScript in client remote browsers. For regular web apps performing the requests in the server environment, this pattern is not so important as the latency is very much smaller than for remote client apps."),(0,r.kt)("p",null,"Depending on the API gateway you use, it might be able to perform this aggregation. However, in many cases it's more flexible to create aggregation microservices under the scope of the API gateway."),(0,r.kt)("h2",{id:"gateway-offloading"},"Gateway Offloading"),(0,r.kt)("p",null,"Depending on the features offered by your API gateway, you can offload functionality from individual microservices to the gateway, which simplifies the implementation of each microservice. "),(0,r.kt)("p",null,"This approach works well for specialized features that can be complex to implement properly in every internal microservice, such as the following functionality:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Authentication and authorization"),(0,r.kt)("li",{parentName:"ul"},"Service discovery integration"),(0,r.kt)("li",{parentName:"ul"},"Response caching"),(0,r.kt)("li",{parentName:"ul"},"Rate limiting and throttling"),(0,r.kt)("li",{parentName:"ul"},"Load balancing"),(0,r.kt)("li",{parentName:"ul"},"Logging, tracing, correlation"),(0,r.kt)("li",{parentName:"ul"},"Headers, query strings, and claims transformation")),(0,r.kt)("h2",{id:"backend-for-frontend-bff"},"Backend for Frontend (BFF)"),(0,r.kt)("p",null,"Similar to the API gateway pattern, the Backend for Frontend (BFF) pattern instead uses multiple gateways - each on dedicated to a specific frontend channel.  For example, a native mobile app front and a traditional desktop browser web app would each have an API gateway they integrate, which would in turn aggregate and serve the required data in an appropriate format."),(0,r.kt)("p",null,"For more information on this pattern, see ",(0,r.kt)("a",{parentName:"p",href:"/blog/what-is-the-backend-to-frontend-design-pattern/"},"this article"),"."),(0,r.kt)("h2",{id:"kuroco-api-management"},"Kuroco API Management"),(0,r.kt)("p",null,"Kuroco\u2019s backend offers API gateway functionality out of the box, with built-in tracking and analytics."),(0,r.kt)("p",null,"Kuroco allows for logging, security, and metering of your API.  These insights can help your enterprise get a better understanding of how your APIs are being used and how they are performing. They do this by letting you view near real-time analytics reports and identifying trends that might impact your business. In addition, you can view logs about request and response activity for further online and offline analysis."),(0,r.kt)("p",null,"You can get started today and test it out for free, or feel free to reach out to our ",(0,r.kt)("a",{parentName:"p",href:"https://hisashihasebe.github.io/document_archive_public/202401/docs/about/support/"},"customer support team")," if you have any questions!"))}m.isMDXComponent=!0}}]);