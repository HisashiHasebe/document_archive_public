"use strict";(self.webpackChunkkurokuro=self.webpackChunkkurokuro||[]).push([[11477],{30010:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"what-is-a-reverse-proxy","metadata":{"permalink":"/blog/what-is-a-reverse-proxy","source":"@site/blog/what-is-a-reverse-proxy.md","title":"What is a reverse proxy","description":"Blog article discussing reverse proxies and how they differ from traditional forward proxies.","date":"2022-09-02T00:00:00.000Z","formattedDate":"September 2, 2022","tags":[],"readingTime":2.845,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-09-02T00:00:00.000Z","title":"What is a reverse proxy","description":"Blog article discussing reverse proxies and how they differ from traditional forward proxies.","slug":"what-is-a-reverse-proxy","authors":"diverta","hide_table_of_contents":false},"nextItem":{"title":"A Guide to Choosing an Enterprise Headless CMS","permalink":"/blog/guide-to-choosing-an-enterprise-headless-cms"}},"content":"Blog article discussing reverse proxies and how they differ from traditional forward proxies.\\n\\n\x3c!-- truncate --\x3e\\n\\n# Proxy Servers: Overview\\nThe Internet can be thought of as many devices (computers) communicating data with each other.  Devices that fetch resources (such as your personal computer, using a web browser) are \'clients\', while devices sending the data are \'servers\'.  While direct client-to-server communication is possible, due to security concerns it is more common to have other devices (proxy servers) in the middle to handle this.\\n\\nA proxy server is simply a device that relays data between other devices.  These devices receiving data from proxies can be clients, or other servers.  A traditional forward proxy server is placed in front of other servers, and relays their data to clients.  This serves several important purposes:\\n\\n* Masking IP addresses of original servers, to provide anonymity and protect from prying eyes\\n* Routing and access control, to ensure users only access resources they are supposed to (or to enable users to bypass browsing restrictions, ex. when they are located in certain countries)\\n* Caching of users\' data for improved performance\\n\\n## Reverse Proxy Servers\\nAs the name implies, a reverse proxy server operates in the opposite direction of a forward proxy.  Its main purpose is to protect backend servers from potential attack vectors coming from client devices, and also provides extra useful functionality such as:\\n\\n**Load Balancing:** A common function of reverse proxies is routing client requests to different origin servers as needed.  If a website receives millions of visits within a short period of time, any individual server receiving that traffic would be overloaded and fail.  The reverse proxy is programmed to distribute the traffic appropriately over a network of servers, ensuring better performance.  If an individual origin server fails for any reason, the reverse proxy can also prevent traffic from being routed to it (reducing the number of failed requests from clients).\\n\\n**Caching:** A reverse proxy is often capable of detecting the client\'s geographical location.  A client\'s request can then be routed to the nearest server, greatly improving speed and performance.  Often a CDN (content delivery network) will cache a website\'s resources on reverse proxy servers, so clients will have access to the closest geographic server by default.\\n\\n**Compressing Files:** Reverse proxies can compress files being sent from origin servers, ensuring that they are delivered more quickly to clients, take less time to download, and use up less bandwidth.\\n\\n**SSL Handling:** Decryption of SSL certificates can be handled on origin servers, but to save resources a proxy server can handle all this functionality.\\n\\n## How to Set Up a Reverse Proxy\\n1) **Build it in House:**  Large companies with devoted backend teams may consider building out their own reverse proxy system.  This approach requires a lot of resources, as well as capital expenditure on server equipment.  The obvious benefit is that the company will have total control over their system without any limits customization.  While it depends on the specific needs of the company, in most cases reverse proxying can be seen as a utility - it is rare that a custom-built and maintained system would be required.\\n\\n2) **Use a Cloud-based Solution**:  Platforms offering reverse proxying and other solutions on the edge are now widely available as an online utility. Kuroco offers reverse proxying, WAF, and other edge-based solutions out-of-the-box, which can be easily configured and managed at a low cost."},{"id":"guide-to-choosing-an-enterprise-headless-cms","metadata":{"permalink":"/blog/guide-to-choosing-an-enterprise-headless-cms","source":"@site/blog/guide-to-choosing-an-enterprise-headless-cms.md","title":"A Guide to Choosing an Enterprise Headless CMS","description":"A Guide to Help Enterprise Stakeholders Choose a Headless CMS","date":"2022-06-01T00:00:00.000Z","formattedDate":"June 1, 2022","tags":[],"readingTime":6.13,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-06-01T00:00:00.000Z","title":"A Guide to Choosing an Enterprise Headless CMS","description":"A Guide to Help Enterprise Stakeholders Choose a Headless CMS","slug":"guide-to-choosing-an-enterprise-headless-cms","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"What is a reverse proxy","permalink":"/blog/what-is-a-reverse-proxy"},"nextItem":{"title":"Git-based Vs API-centric Headless CMS","permalink":"/blog/git-based-vs-api-centric-headless-cms"}},"content":"A Guide to Help Enterprise Stakeholders Choose a Headless CMS\\n\\n\x3c!-- truncate --\x3e\\n\\nEnterprise CMS platforms have been around for decades, and are an integral part of how large companies manage and deliver their content.  API-centric headless CMSs, on the other hand, are a relatively new technology that have mainly been used by developers working on smaller projects (including blogs and static websites).\\n\\nHowever, with the advent of mobile technology and the internet-of-things, large enterprises are increasingly required to deliver their content to a multitude of different frontend platforms, often via a wide range of microservices bundled together.  Given the importance of websites, mobile apps, and social media for enterprises to interact with their customers and engage in marketing initiatives, content management is of critical importance for their continued success.\\n\\nChoosing the correct headless CMS is essential for content creators and marketers to create and deliver the best experience to customers.  One of the most important factors in making this decision is providing a composable architecture to developers that enable them to easily and rapidly deliver content to any frontend, without having to worry about making potentially breaking changes to the backend.\\n\\n## What Is An Enterprise Headless CMS?\\n\\nAn enterprise headless CMS is built with large organizations in mind, including all the common features they require to build and maintain larger projects, such as enterprise-grade security, infrastructure scalability, user roles and permissions, integrations, content workflows, and API management functionality.  It also provides advanced tools for testing performance and tracking changes made within team environments.\\n\\nWhile the above may have traditionally been provided by monolithic CMSs, this would have typically entailed working within a framework of code coupled together with content data (i.e. the opposite of the \u2018headless\u2019 approach).  There is no practical reason that large enterprises should continue to rely on monolithic frameworks.\\n\\nIn the same sense that microservices architectures are freeing up data within large organizations to be consumed more broadly, a good headless CMS is able to integrate with and bundle data from many other sources and serve it to appropriate audiences.  This includes ERP, CRM, and other platforms that many enterprises rely on.\\n\\n### Limitations of the Traditional Monolithic CMS\\n\\nWith the advent of cloud infrastructure on the internet, the need to centralize data into a monolithic backend coupled to a single frontend has been replaced by microservices architecture and API gateways.  This allows data to be consumed much more easily, by remote clients, unlocking the power of data that had previously been cloistered.\\n\\nThe biggest advantage of microservices architecture is that enterprises do not necessarily need to rebuild their backend systems from scratch, but can rather add a layer above them to write and consume data from virtually any source using APIs.  This is not a short-term fad within the industry, but rather a profound change that is transforming the way enterprises use their data - which is increasingly becoming one of their most valuable assets.\\n\\nTraditional monolithic CMSs are unable to meet this need for flexibility, and are being replaced by headless CMSs that open up enterprise data to the world.\\n\\nMonolithic CMSs are struggling to meet the demands of modern businesses as they are too restrictive and have some drawbacks that are causing their downfall. Some of these drawbacks include: \\n\\n### Overabundance of Features\\n\\n\u201cFeature creep\u201d is a common issue with large, monolithic CMS platforms.  While it may seem like a good thing to have access to a ton of extra features and tools, it is nearly always better to have a headless CMS that gives developers freedom to integrate with whichever 3rd party tools they need (such as CRM and ERP platforms).\\n\\nThe CMS itself should focus on providing content creators a great user experience, and empowering developers with API management functionality, and not crowd the platform with too many other unnecessary features.\\n\\n### Expensive to Maintain\\nLarge, bloated software platforms crammed full of extra features also typically cost much more to maintain, and if custom integrations are required to replace the built-in tools with integrations with best-in-class 3rd party solutions, the enterprise can end up paying for redundant services - adding further to the cost burden.\\n\\n### Complicated to Integrate\\nTraditional monolithic CMS platforms often have APIs built-in, but in reality, are more complicated to integrate with that modern headless CMSs using standard REST and GraphQL APIs.\\n\\n## Further Reasons to Choose a Headless CMS\\n\\nWhile the drawbacks of using a monolithic CMS might be obvious to some, some enterprise managers may be reluctant to make changes to systems that already work.  Below are some further reasons that enterprises should strongly consider taking the plunge into the upgrading their systems with headless solutions:\\n\\n### Future-proof architecture\\nThe biggest advantage of headless architecture is that frontends can be easily updated, or totally rebuilt from scratch, without having to worry about making breaking changes to the backend - thanks to the API-first approach.  Data can be consumed by any or multiple frontends, with rapid iterations possible.  This leads to much faster delivery of new product features, and greater productivity overall.\\n\\n### Increase marketer and content creator productivity\\nIn addition to freeing up frontend developers to rapidly build out new features, headless CMSs also empower marketers and content creators to easily create tailored content for any frontend they want.  For example, if they wish to run separate desktop and mobile campaigns, or customize or A/B test their blog content for different device types, this can be accomplished much more easily using a headless CMS.\\n\\n### Centralized content hub\\nUnlike with monolithic CMSs, where content is typically siloed within the specific site, a headless CMS will enable content to be centralized and much more easily shared across multiple departments or business divisions.\\n\\n### Content workflows\\nTraditional monolithic CMSs are limited in which content can be planned out across different frontends, whereas a good headless CMS will enable workflow planning across any frontend.\\n\\n### API-driven approach\\nComposable API-driven architecture enables enterprises to make changes to their software stack more easily, and prevents the need to have to change their backend systems to accommodate new technologies that come out.  A good headless CMS with API management functionality can be added as a layer above the existing backend infrastructure.  The backend can then be treated as a \u2018black box\u2019, with any frontend able to communicate with it using standard REST or GraphQL APIs.\\n\\n### Advanced Personalization and User Targeting\\nIn addition to serving content to different frontends, headless CMSs can also integrate with enterprise CRM platforms, and other localization or analytics tools to provide tailored content to different types of customers in different market segments and locations around the world.\\n\\n### Kuroco: The Enterprise Headless CMS\\nIf the above benefits are of interest to your enterprise, we hope you\'ll give Kuroco a try! Our headless CMS is built with enterprises and robust API management in mind. Our platform is one of the best in the market for integrating with older legacy systems, allowing you to open up your data without having to rebuild your older systems from scratch. We offer powerful API customization features out of the box, and an easy to use headless CMS interface for both technical and non-technical users.\\n\\nYou can get started today and test it out for free, or [reach out to our team](https://kuroco.app/docs/about/support/) if you have any questions!"},{"id":"git-based-vs-api-centric-headless-cms","metadata":{"permalink":"/blog/git-based-vs-api-centric-headless-cms","source":"@site/blog/git-based-vs-api-centric-headless-cms.md","title":"Git-based Vs API-centric Headless CMS","description":"A description of the differences between Git-based and API-centric CMSs","date":"2022-05-31T00:00:00.000Z","formattedDate":"May 31, 2022","tags":[],"readingTime":6.975,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-05-31T00:00:00.000Z","title":"Git-based Vs API-centric Headless CMS","description":"A description of the differences between Git-based and API-centric CMSs","slug":"git-based-vs-api-centric-headless-cms","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"A Guide to Choosing an Enterprise Headless CMS","permalink":"/blog/guide-to-choosing-an-enterprise-headless-cms"},"nextItem":{"title":"API Gateway vs Backend For Frontend","permalink":"/blog/api-gateway-vs-backend-for-frontend"}},"content":"A description of the differences between Git-based and API-centric CMSs\\n\\n\x3c!-- truncate --\x3e\\n\\nSince monolithic CMS (content management system) platforms like WordPress and Drupal were popularized in the mid 2000s, the web development ecosystem has changed considerably.  Most recently, with the advent of mobile devices, the shift has been towards content delivery that is decoupled from the various frontends it is served to.\\n\\nTraditional CMS platforms still make up a large portion of the total market share, but due to many drawbacks, including poor performance, security concerns, cost, and lack of developer freedom, the headless CMS ecosystem is growing rapidly - both among smaller businesses and large enterprises.\\n\\nWithin the headless CMS space, there are 2 main approaches:  API-centric and Git-based.  This article will discuss some of the trade-offs of choosing either type of headless CMS, depending on the types of projects your company is working on.\\n\\n## Overview of Git-based vs API-centric CMSs\\n\\nThe headless CMS ecosystem is still relatively new - and to date, the 2 main approaches have been either Git-based or API-centric solutions.\\n\\n### Git-Based\\nThe Git version control system (VCS) is a technology that stores developer files in a repository and tracks changes made over time.  Repositories can be branched and merged, allowing teams to make changes without the risk of making permanent breaking changes to code while it is being tested.\\n\\nA Git-based CMS is able to manage the content in a user-friendly interface, and integrate with the Git repository to update changes made, which then triggers a rebuild of the frontend.  Typically, this is done online using platforms like GitHub, which can be accessed easily by remote teams.\\n\\n### API-centric\\nAn API (application programming interface) is how applications communicate with each other and send/consume data.  An API-centric CMS allows content creators to manage their content in a user-friendly interface, which will update their content data in a database.  \\n\\nThis data, typically in REST or GraphQL format, can then be consumed by their applications (either server-side, or directly by the frontend, depending on the type of project).\\n\\n## Git-Based CMS Trade-offs\\n\\nAs Git-based CMSs are dependent on the Git version control system, there are some trade offs related to this approach:\\n\\n### Benefits\\n* Git comes with backup functionality built in, reducing risk of breaking changes.\\n* Most developers already use Git for their frontend code, so keeping content in the same space can be convenient and easy to keep track of.\\n* No vendor lock-in - Git is an open source technology used by most developers in the industry.\\n* Low cost and ease of use - Git and most Git-based CMSs are free (or low-cost) to use and easy to set up.\\n\\n### Drawbacks\\n* Not as scalable for multiple front ends.\\n* Not as robust for updating live or heavy static content, due to limitations of Git architecture.\\n* Data querying limitations, compared to a dedicated API customized for frontend consumption.\\n\\n## API-Centric CMS Trade-offs\\n\\nAPI-centric CMS are more difficult to generalize, since the differences among platforms in this category may vary widely in terms of features and functionality.\\n\\n### Benefits\\n* Better suited for applications serving multiple frontends, especially when those frontends are consuming customized API endpoints.\\n* Able to handle large, complicated data sets more effectively than Git-based CMSs.\\n* More robust at handling content that changes frequently.\\n* More customizable - there are very few limitations in terms of how API-centric CMS are built, as they do not need to conform to Git.\\n\\n### Drawbacks\\n* Backup is not automatically built-in, as with Git.\\n* Many API-centric CMSs are SaaS offerings, which can become expensive if storage or performance requirements are increased.\\n* Self-hosted API-centric CMSs can require a lot of developer overhead to set up and maintain.\\n* More complexity overall - integrating your API-centric CMS with your application can involve more developer involvement to ensure APIs are being managed and/or consumed properly.\\n\\n## Comparing the Pros and Cons of Each Approach\\n\\nBoth Git-based and API-centric headless CMSs are effective solutions compared to legacy monolithic CMSs, but developers will need to choose which approach works best for them, depending on their requirements.\\n\\n### Convenience of Working with a Git-based CMS\\nThe most obvious benefit of choosing a Git-based CMS is that most developers are already familiar with this system, and using it for their frontend code.  Adding a Git-based CMS is typically free (or very low cost) and relatively easy to set up - giving content creators a way to update their content without having to make a request to a developer each time.\\n\\n#### Lack of Overall Scalability\\nGit-based CMSs work well when you understand the scale of your project and plan your content and data formats ahead of time, optimized for the frontends you need.  For scaling to much larger projects with multiple frontends, however, the Git-based approach is likely to run into limitations.\\n\\n### Customizability of Working with an API-centric CMS\\nAPIs are the universal format for data consumption, meaning they can integrate with basically any type of frontend and be optimized accordingly.  Whether your CMS has a single API gateway to handle all frontends, or even a BFF (\u2018backend for frontends\u2019) architecture to customize endpoints for each frontend, the result is that you can scale your application almost without limit.\\n\\nIn terms of \u2018future proofing\u2019 your project, the API-centric approach is nearly always going to be the better option, assuming this is within the scope of your project.\\n\\n#### Higher Developer Overhead\\nWhen dealing with API management, developers will need to be involved to ensure the APIs are working properly, securely, and efficiently.  This may be overkill for some smaller projects, and will depend on the specific use-cases of your application.\\n\\n## Common Use Cases\\nThe following are some of the more common use cases for both Git-based and API-centric CMSs:\\n\\n### SSG (Static Site Generator) Websites\\nSSG websites are increasing in popularity, spurred on by the expansion of the Jamstack ecosystem.  Popular frameworks like Jekyll, Hugo, Gatsby, Gridsome, Next and Nuxt are ideal for building static websites that can be served on CDNs at blazing speeds.\\n\\nWhile both Git-based and API-centric CMS are excellent choices for managing content on SSG sites, Git-based are particularly simple and easy to set up for smaller projects like blogs, portfolio sites, or simple landing pages.  \\nFor more complicated sites used by large enterprises, API-centric architecture will nearly always be preferred.\\n\\n### E-Commerce\\nE-commerce sites built with next-generation frameworks like React, Vue, or Angular will benefit from headless CMSs.  Similar to SSG websites, the size and complexity of the project will determine the best approach to take - for simpler and smaller projects, the Git-based approach is more likely to be feasible, while projects aiming for scalability and \u2018future-proofing\u2019 their growth should strongly consider an API-centric approach.\\n\\n### Multiple Frontends\\nIf your goal is to create a multi-platform application using many different frontends (like different native apps for mobile devices), then you will almost certainly need to take an API-centric approach when choosing a CMS.\\n\\nGit-based integrations can also work, depending on the project, but will be limited compared to having a robust API powering your different frontends.\\n\\n### Microservice Heavy Architecture\\nIf your project is complex, and consuming data from many different sources, then you will also want to strongly consider an API-centric approach to choosing your CMS.  Most good API-centric headless CMSs will have API gateway functionality built in, allowing you to bundle different microservices for your front ends to consume.  This can be much more difficult using Git-based integrations as the application grows in scale and complexity.\\n\\n## So, Which Approach Should I Choose?\\nAs discussed, both approaches are excellent, depending on your requirements.  If you are building a simpler or leaner project in which you prefer to keep developer overhead and costs to a minimum, then you should consider the advantages of a Git-based approach.  This will also ensure that your content is backed up.\\n\\nFor larger projects requiring more customization and scalability, and when you want to \u2018future proof\u2019 your work as it grows over time, then you should strongly consider taking an API-centric approach.\\n\\n## Have any Questions?\\nIf you\'d like to know more about headless CMS solutions for your enterprise, please don\'t hesitate to\\n[reach out to our team](https://kuroco.app/docs/about/support/) to answer any of your questions."},{"id":"api-gateway-vs-backend-for-frontend","metadata":{"permalink":"/blog/api-gateway-vs-backend-for-frontend","source":"@site/blog/api-gateway-vs-backend-for-frontend.md","title":"API Gateway vs Backend For Frontend","description":"Comparison of similarities and differences of an API gateway vs BFF","date":"2022-05-05T00:00:00.000Z","formattedDate":"May 5, 2022","tags":[],"readingTime":4.58,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-05-05T00:00:00.000Z","title":"API Gateway vs Backend For Frontend","description":"Comparison of similarities and differences of an API gateway vs BFF","slug":"api-gateway-vs-backend-for-frontend","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"Git-based Vs API-centric Headless CMS","permalink":"/blog/git-based-vs-api-centric-headless-cms"},"nextItem":{"title":"What is a Progressive Web App?","permalink":"/blog/what-is-a-progressive-web-app"}},"content":"Comparison of similarities and differences of an API gateway vs BFF\\n\\n\x3c!-- truncate --\x3e\\n\\nAn API gateway is a single point of entry for all clients fetching data from the system, while a [backend-for-frontend (BFF)](/blog/what-is-the-backend-to-frontend-design-pattern/) is tailored to a specific frontend - typically with multiple BFFs corresponding to multiple frontends.  However, to better understand the reasoning behind each approach, it is worth considering their differences.\\n\\n## What is an API Gateway?\\n\\nAn API gateway is essentially the filter through which all clients must pass when trying to access resources within the system.  To quote [Redhat.com](https://www.redhat.com/en/topics/api/what-does-an-api-gateway-do):\\n\\n>\u201cAn API gateway acts as a reverse proxy to accept all application programming interface (API) calls, aggregate the various services required to fulfill them, and return the appropriate result.\u201d\\n\\n## How is a BFF Different from an API Gateway?\\n\\nA BFF is actually a type of API Gateway.  In fact, both perform the same function, with the main difference being in scope - or how many clients they interact with.  A BFF being tailored to the requirements a specific client, usually a frontend view of an application, while an API gateway genrally functions as a single gateway for the majority (or all) of the clients to access data.\\n\\n### Similarities\\nBoth architectural patterns serve to achieve the same goal at a high level, i.e. decoupling the backend microservices of a system from the frontend clients.  This makes it much easier for clients and services with different protocols to interact with each other, without having to duplicate a lot of code for each in order to achieve the same result.\\n\\nWith an API gateway, each client only needs to know the location of the API gateway itself, instead of all the different microservices within the system.  The API gateway is able to handle functionality like authentication, and bundling of different microservices resources to be served to the client.  A BFF also does this, but on a more granular level.\\n\\n### Differences\\nAs mentioned, the main difference is in how many clients are served.  A standard API gateway handles requests from all the clients interacting with the system, while a BFF only handles a specific client.  An example would be an app with 2 different frontends: \\n\\n1. Desktop browser web client\\n2. Native mobile client (iOS or Android)\\n\\nIf each of these frontends were given their own dedicated gateway to access resources in the system, i.e. with custom tailored endpoints that would meet their precise needs (as each might require different data depending on the screen size of devices used etc.), then each gateway would be considered a BFF.\\n\\n## Should I Use a Standard API Gateway or BFF?\\n\\nThere are trade-offs to either approach.  Generally a BFF pattern is ideal, but it is also more complicated to maintain as it requires more granular customization.  A standard API Gateway can also be optimized to function more efficiently on multiple frontends, and essentially \'emulate\' a proper BFF architecture in its behavior (with some limitations).\\n\\nThe question largely boils down to a few key factors such as how many clients the application has to interact with, the scale of the application, and the resources the business has to devote to customizing this architecture.\\n\\n### Complex applications with many clients\\n* May need to support different protocols like GraphQL vs REST APIs serving JSON.\\n* May have dedicated teams working on each client, with different needs.\\n* May have an equally complex system of microservices, needing to be bundled/aggregated by gateways before being served to clients.\\n\\nIn the above cases, it may be worth investing the required time and resources into building a proper BFF architecture.  This would allow each team that is responsible for a specific frontend to manage their API needs by themselves without having to worry about what other teams are doing.  Having a dedicated BFF for each frontend would also ensure they are able to access data resources in the most efficient manner, which is required for the frontend developers work effectively (and not having to constantly be making requests for potentially breaking changes to the backend team).\\n\\nAlternatively,\\n\\n### Simple applications with only one or a few clients\\n* May operate with just a single protocol.\\n* Be managed by a single team.\\n* Have only a single authentication method for all users.\\n* Have a relatively simple system of microservices, able to be handled by a single gateway.\\n\\nIn this case, all the API needs of the application can likely be handled by a single API gateway without any issue.  It would be overkill to build out and manage multiple BFF gateways, and frontend teams would be able to access the data they need - perhaps not in the most efficient way possible - but without any issue.\\n\\n## Kuroco is the Headless CMS Built with API Management in Mind\\n\\nKuroco is a feature-rich headless CMS that enables enterprise teams to easily configure and customize API endpoints.  We offer a single API gateway out-of-the-box, which can be easily customized to function similarly to a BFF pattern.  This enables you to access all your enterprise\'s data with ease, without having to make complicated, potentially breaking changes to your backend architecture or do expensive rebuilds.\\n\\nKuroco is the best solution of its type for enterprises looking to decouple their backend and frontend concerns.  If you are interested in learning more about how our solutions can help your business, please [contact us](https://kuroco.app/docs/about/support/) and we will be happy to answer any questions you have."},{"id":"what-is-a-progressive-web-app","metadata":{"permalink":"/blog/what-is-a-progressive-web-app","source":"@site/blog/what-is-a-progressive-web-app.md","title":"What is a Progressive Web App?","description":"A discussion of Progressive Web Apps, compared with native apps","date":"2022-05-05T00:00:00.000Z","formattedDate":"May 5, 2022","tags":[],"readingTime":6.32,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-05-05T00:00:00.000Z","title":"What is a Progressive Web App?","description":"A discussion of Progressive Web Apps, compared with native apps","slug":"what-is-a-progressive-web-app","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"API Gateway vs Backend For Frontend","permalink":"/blog/api-gateway-vs-backend-for-frontend"},"nextItem":{"title":"Differences Between Jamstack and Conventional Websites","permalink":"/blog/differences-between-jamstack-and-conventional-websites"}},"content":"A discussion of Progressive Web Apps, compared with native apps\\n\\n\x3c!-- truncate --\x3e\\n\\nModern web development has come a long way since the early days of basic HTML, CSS, and JavaScript sites.  More recently, the focus has shifted away from being exclusively on web browsers to native mobile apps built for iOS and Android devices.  Native apps bring a lot of functionality that traditional websites were not able to offer, such as a more immersive user experience and seamless offline usage.\\n\\nMost large online business now offer customers a native web app experience, for a broad range of activities from online banking, to food delivery and other e-commerce sites, to social media, to government services.  The near ubiquity of such apps has given rise to the expression \\"I bet there\'s an app for that!\\".\\n\\nAs the state of web technology has continued to improve over time, the need for web apps that can function in a similar manner to such native apps has increased - finally giving rise to \u201cprogressive web applications\u201d (or PWAs).\\n\\n## What Exactly is a Progressive Web App?\\n\\nAs mentioned, a PWA is an application built with web technologies stacks, i.e. using HTML, CSS, and JavaScript.  However, these apps contain innovations that enable them to function and feel more like a native app.\\n\\nSome of the major improvements include push notifications and ability to use the apps offline.  PWAs also leverage the power of modern APIs to asynchronously deliver content in real time, without having to constantly reload pages from the web server.  PWA frameworks typically come with a wide range of open-source community plugins and options that make development much easier and faster (not having to be built from scratch).  PWAs are also downloadable, and can be installed on devices much like a native app (albeit with some limitations).\\n\\nOne of the main benefits PWAs is that companies can build a single app that runs on both iOS and Android devices.  While larger companies will still also build native apps (usually with a prompt to download it, targeting new users trying out the web app first), it is possible to maintain just a single codebase and offer a PWA - if the company is smaller and has limited developer resources.\\n\\nMany large companies that offer both native and web apps have still taken the PWA approach for their web offerings, such as Uber, Tiktok, Spotify, and Twitter.  Most of these PWA apps can be installed on the user\u2019s home screen on their device.\\n\\n## Common Features of a PWA\\n\\n### Responsive Design\\nBecause PWAs are built for web browsers, which include both desktop and mobile browsers, it is crucial that they work well on all device sizes.  This can be achieved either via responsive design principles (i.e. having CSS classes active depending on the media query for the device being used), or by having unique different desktop, tablet, or mobile views that load depending on the device.  Regardless, the web app should work seamlessly with any screen size, and have content display on any view-port size.\\n\\n### Option to Install the PWA\\nPWAs can be installed to the home screen of the user\u2019s device, giving it a similar look and feel to a native app.  This tends to increase user engagement substantially, compared to forcing users to visit the website directly each time they want to use the app.\\n\\n### Available to Use Offline\\nA key feature of most PWAs is the ability to cache or store content locally, so that the app will continue to work seamlessly when it is offline.  This is crucial for keeping users engaged and providing a better user experience (similar to native apps).  Examples of offline usage would include the ability to read or edit content posted online, or store media files (like music or videos) on the device to be used even when the app is not connected to the Internet.\\n\\n### SEO\\nOne of the main advantages that PWAs have over native apps is that they can appear directly in online searches.  While native apps can be discovered on landing pages or linked to websites, they typically need to be downloaded from app stores first.  PWAs are still websites, so they are indexed in search engines like Google - having a popular PWA is therefore beneficial from an SEO standpoint.\\n\\n## PWAs vs Native Apps: Key Comparisons\\n\\n### Cost of Development\\nPWAs are usually substantially cheaper to develop, test, and maintain than native apps.  Native apps require developer teams that specialize in certain languages (for iOS and Android), and in most cases both are required to serve the full market of users.\\n\\nIn the case of PWAs, the frontend is nearly always built in JavaScript, often a modern framework like React, Vue, or Angular.  JavaScript developers are generally more versatile (full-stack), and only need to maintain a single codebase for all platforms serviced by the PWA.  There is also less complexity, as it is not necessary to work with iOS or Android SDKs.\\n\\nOverall this will reduce the cost dramatically, making it a much more feasible option for smaller companies or start-ups, before they scale to the point that native apps would be required.\\n\\n### Security\\nWhile native apps are typically secure due to the infrastructure of the operating systems they are built on, this also requires a lot of measures to be implemented (such as multi-factor authentication).\\n\\nPWAs are required to run on the HTTPS protocol, which makes them highly secure when communicating from client to server.  However, it is important to note that some modern JavaScript frameworks can allow for vulnerabilities to be built in (like storing vulnerable information in the browser), so steps should be taken to safeguard against this.\\n\\n## Key Requirements for Building PWAs\\n\\n### Frontend Frameworks\\nThe most common JavaScript frameworks for building PWAs are React, Vue, and Angular.  In particular, open source frameworks like Next.js (for React) and Nuxt.js (for Vue) have PWA projects built in, which can be installed with a few clicks of a button, and be configured however needed.\\n\\n### HTTPS Protocol\\nAn https connection is necessary to securely transfer data between your PWA\u2019s frontend and the backend server.\\n\\n### Frontend Shell\\nThis is the initial view the user will see, usually server-side rendered HTML, serving as the skeleton for the app.  This view should load very quickly, and have placeholder or loading view components when necessary to show the user what is happening.  Data is then pulled in via APIs, and populated into the app when loaded.\\n\\n### Service Workers\\nIn order for your PWA to continue functioning offline, one of the key technologies required are service workers that run background code and perform advanced caching of data as needed.  The main function of the service workers is to detect changes in the network, fetch data asynchronously and push notifications to the user when their Internet connection is restored.  This provides a much smoother overall user experience.\\n\\n## Kuroco works Hand-in-Glove with PWAs\\nIf you are thinking of building a PWA for your business, it is likely that you will need a content management system (CMS) to manage your content across multiple platforms.  Kuroco is an ideal solution for PWA projects, with API management functionality that allows you to customize endpoints for different frontends.\\n\\nOur solutions work seamlessly with all major frameworks like React/Next and Vue/Nuxt commonly used to build PWAs.  If you would like to learn more about how our products can help your business, please [reach out to us](https://kuroco.app/docs/about/support/) and we will be happy to answer any questions!"},{"id":"differences-between-jamstack-and-conventional-websites","metadata":{"permalink":"/blog/differences-between-jamstack-and-conventional-websites","source":"@site/blog/differences-between-jamstack-and-conventional-websites.md","title":"Differences Between Jamstack and Conventional Websites","description":"This section explains how websites built on Jamstack differ from conventional sites.","date":"2022-04-13T00:00:00.000Z","formattedDate":"April 13, 2022","tags":[],"readingTime":3.77,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-13T00:00:00.000Z","title":"Differences Between Jamstack and Conventional Websites","description":"This section explains how websites built on Jamstack differ from conventional sites.","slug":"differences-between-jamstack-and-conventional-websites","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"What is a Progressive Web App?","permalink":"/blog/what-is-a-progressive-web-app"},"nextItem":{"title":"Jamstack Architecture","permalink":"/blog/jamstack-architecture"}},"content":"This section explains how websites built on Jamstack differ from conventional sites.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What is a conventional website?\\nIn this guide, a conventional website refers to one implemented with the following basic server architecture. There may be some variations depending on the specific case: for example, PHP websites have an integrated HTTP server and application server.\\n\\n#### Web (HTTP) server\\nReceives a request from a web browser and calls the application server. It then receives the HTML and returns it to the browser. Some web servers hold static content and return the HTML and images unchanged.\\n\\n#### Application server\\nReceives data from the web server and exchanges information with the database server. Subsequently, it generates the HTML and sends it to the web server.\\n\\n#### Database server\\nA database server stores the information on users, products, contents, etc. It returns the requested data when called by the application server.\\n\\nBefore the advent of web API-based sites, the above architecture was commonly implemented.\\n\\n## Similarities between conventional and Jamstack websites\\nConventional and Jamstack websites may look identical. When you visit a site in your browser, you may not be able to tell which one it is at first glance.\\n\\n## Differences between conventional and Jamstack websites\\nThe main difference between the two is the task flow of the browser from the site visit to the content display.\\n\\n#### How conventional websites work\\nA conventional website (e.g., CMS, e-commerce site) is displayed via the following process.\\n\\n![Image from Gyazo](https://t.gyazo.com/teams/diverta/fcf26a09cc3493b6585c147d090fcdf9.png)\\n\\n1. The browser sends a request to the web server.\\n2. The application server and database server exchange information within the web server.\\n3. The application server generates the HTML using data.\\n4. The web server returns the HTML to the browser.\\n5. Finally, the browser displays the HTML.\\n\\nThe browser and website engage in the above exchange each time you move to a different page.\\n\\n### How Jamstack websites work\\nIn contrast, a website built on Jamstack follows the mechanism below.\\n\\n![Image from Gyazo](https://t.gyazo.com/teams/diverta/986ebae6068ccbcc83d9eddbc489d18b.png)\\n\\n1. The browser sends a request to the web server (typically a CDN).\\n2. The web server (or CDN) returns the HTML to the browser.\\n3. The browser displays the HTML.\\n\\nThe application server does not interact with the database or generate the HTML. Since no dynamic processing is involved, the system load is greatly reduced, and the website can display much faster. Moreover, the CDN also speeds up the content delivery and display.\\n\\nThe dynamic parts (e.g., payment, authentication, certain content types) are obtained through external services known as \\"microservices.\\" Since they often provide very limited functionality, the browser usually calls multiple microservices as needed for a single website.\\n\\n![Image from Gyazo](https://t.gyazo.com/teams/diverta/c5485119b9f103fd4dbdeeaa3f6fc0cd.png)\\n\\n4. The browser sends a request to the external service (microservice) API.\\n5. The external service returns the processing results to the browser.\\n6. The browser then rewrites the HTML according to the processing results.\\n\\nUnlike the case of a conventional website, the external service returns the data mostly as JSON (instead of HTML) to the web browser. The browser then displays the data using JavaScript.\\n\\n## Advantages of display processing by the web browser\\nThe difference between server-side HTML generation and display processing done by the browser lies in the display speed. For the browser, displaying HTML requires heavy processing, which includes interpreting the DOM, applying style sheets, and calculating the heights and widths of any images. This process is repeated with every single page transition, causing lags in the site display.\\n\\nWith Jamstack, only the data is returned, so display elements are replaced only where necessary. This eliminates the need to re-display the entire HTML and greatly improves the loading speed. Your UX (user experience) also improves with every click from one screen to another.\\n\\nFurthermore, Jamstack eliminates the need for the server to generate HTML. Sites that require authentication often have trouble caching the generated HTML. However, with Jamstack, data that does not rely on user authentication (such as product lists) can be cached without any issues. This also helps to reduce the server load.\\n\\n## Kuroco Is Built with Enterprise-Grade Projects in Mind\\n\\nKuroco, the enterprise headless CMS, has all the serverless infrastructure your enterprise project would need to be highly scalable, secure, and performant.\\n\\nKuroco also allows you to [configure your API](/blog/api-management) with different paths containing different microservice endpoints for each frontend you have.\\n\\nYou can get started today and test it out for free, or feel free to [reach out to our customer support team](https://kuroco.app/docs/about/support/) if you have any questions!"},{"id":"jamstack-architecture","metadata":{"permalink":"/blog/jamstack-architecture","source":"@site/blog/jamstack-architecture.md","title":"Jamstack Architecture","description":"The Jamstack architecture can be divided into four types based on the HTML rendering method.","date":"2022-04-13T00:00:00.000Z","formattedDate":"April 13, 2022","tags":[],"readingTime":2.425,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-13T00:00:00.000Z","title":"Jamstack Architecture","description":"The Jamstack architecture can be divided into four types based on the HTML rendering method.","slug":"jamstack-architecture","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"Differences Between Jamstack and Conventional Websites","permalink":"/blog/differences-between-jamstack-and-conventional-websites"},"nextItem":{"title":"Pros and Cons of Jamstack","permalink":"/blog/pros-and-cons-of-jamstack"}},"content":"The Jamstack architecture can be divided into four types based on the HTML rendering method:\\n\\n\x3c!-- truncate --\x3e\\n\\n* SPA (single page application)\\n* SSG (server-side generation)\\n* SSR (server-side rendering)\\n* ISR (incremental static regeneration)\\n* This section explains the differences between them.\\n\\n## Comparison at a glance\\nThe table below summarizes the similarities and differences between the four types:\\n\\n|   |SPA|SSG|SSR|ISR|\\n|---|:---:|:---:|:---:|:---:|\\n|**Rendering location**|Client|Server|Server|Server|\\n|**Page rendering start time**|Upon receiving response|Upon receiving request|Page is generated before request|Upon initial request (within expiration period)|\\n|**Page content freshness**|\u2605\u2605\u2605|\u2605\u2605\u2605|\u2605|\u2605\u2605|\\n|**SEO**|\u2605|\u2605\u2605\u2605|\u2605\u2605\u2605|\u2605\u2605\u2605|\\n|**Display speed**|\u2605\u2605|\u2605\u2605\u2605|\u2605|\u2605\u2605\u2605 (Generated upon initial request)|\\n|**OGP for each page**|\u2715|\u2605\u2605\u2605|\u2605\u2605\u2605|\u2605\u2605\u2605|\\n|**Security**|\u2605|\u2605\u2605\u2605|\u2605|\u2605\u2605|\\n|**Server load**|\u2605\u2605|\u2605\u2605\u2605|\u2605|\u2605\u2605|\\t\\n\\n## SPA (single page application)\\nSPA, also known as CSR (client-side rendering), renders HTML on the client side. This type of architecture returns the HTML on the initial request - this is mostly done statically, but it can also be dynamic. The JavaScript/CSS code within the HTML is then requested and returned.\\n\\nIn many cases, the data required to display more content is also retrieved via API. The initial display tends to be slightly slower as the API is only processed after the initially retrieved HTML is rendered.\\n\\n![Image from Gyazo](https://t.gyazo.com/teams/diverta/eab168ac19d35601a3727b0556576d07.png)\\n\\nUpon pressing a button or initiating a page transition, the client makes a request to the server as needed. Sometimes no request is needed and JavaScript alone is enough to process the screen transition. The server returns the minimum amount of data requested for the client-side rendering. Since there are only minor differences in the returned data after the initial request, the display process becomes much faster.\\n\\n![Image from Gyazo](https://t.gyazo.com/teams/diverta/352ecf7a12ec7d54ec29478cc50603d7.png)\\n\\n## SSG (static site generation)\\nSSG, the second type of architecture, generates static HTML, JavaScript, and CSS in advance on the server side and registers them in the CDN. As a result, the display process is fast all around, not just for the initial request.\\n\\n![Image from Gyazo](https://t.gyazo.com/teams/diverta/1c47beae6ef76bd1be4325520b1d7c11.png)\\n\\nOne problem with SSG is that the content may be outdated depending on how often it is generated. Therefore, to ensure an effective CDN cache, set a long cache lifetime and avoid including content that is updated frequently.\\n\\n## SSR (server-side rendering)\\nUnlike CSR, SSR renders content on the server side. This means that the content is always up-to-date, since the HTML to be displayed is generated by the server. However, content caching with SSR is more difficult, slower, and causes a greater server load compared to CDN caching.\\n\\n![Image from Gyazo](https://t.gyazo.com/teams/diverta/7e615b53b9db1a06e0c1d87c11f4bf9a.png)\\n\\n## ISR (incremental static regeneration)\\nISR, like SSR, generates pages when a client requests them, but caches them for use on subsequent requests. With the SSG architecture, all the pages are generated in advance, which can take time if there are many of them. But with ISR, pages are generated upon request, so server start-up is much faster.\\n\\nISR allows you to set the expiration date when you create a cache. Once this period is up, the server regenerates the page.\\n\\n![Image from Gyazo](https://t.gyazo.com/teams/diverta/0e57d009f9ff7fbb1c9812aac29b121a.png)"},{"id":"pros-and-cons-of-jamstack","metadata":{"permalink":"/blog/pros-and-cons-of-jamstack","source":"@site/blog/pros-and-cons-of-jamstack.md","title":"Pros and Cons of Jamstack","description":"This section explains the pros and cons of implementing your website with Jamstack.","date":"2022-04-13T00:00:00.000Z","formattedDate":"April 13, 2022","tags":[],"readingTime":4.095,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-13T00:00:00.000Z","title":"Pros and Cons of Jamstack","description":"This section explains the pros and cons of implementing your website with Jamstack.","slug":"pros-and-cons-of-jamstack","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"Jamstack Architecture","permalink":"/blog/jamstack-architecture"},"nextItem":{"title":"API Management","permalink":"/blog/api-management"}},"content":"This section explains the pros and cons of implementing your website with Jamstack.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Advantages\\nJamstack provides the following benefits:\\n\\n* Security\\n* Scale\\n* Performance\\n* Ease of Maintenance\\n* Portability\\n* DX (Developer Experience)\\n\\n#### Security\\nJamstack hosts content as static files and eliminates the need for dynamic content generation by web applications. This makes the overall framework more resistant to malicious attacks. In Jamstack configurations, countermeasures against such attacks are mainly targeted towards the API.\\n\\nThe content delivered from the web server or CDN is pre-generated (i.e., pre-rendered) and read-only. You can keep your dynamic content safe by using a trusted external service vendor.\\n\\n#### Scale\\nMany frameworks and hosting services that implement Jamstack cache data using a CDN. As the expiration period and mechanism of the cache can differ depending on the service, it is best to choose one that matches the characteristics of your website.\\n\\nA CDN provides reliable, fast delivery with optimal load balancing.\\n\\n#### Performance\\nThe loading speed of a page directly affects user experience and conversion. Instead of generating a new page for each request, Jamstack delivers pre-generated content only. Moreover, the use of a CDN further reduces delivery time.\\n\\nMany CDNs deploy delivery servers located near the user for faster delivery. This provides high performance without the need for expensive and complex infrastructure.\\n\\n#### Ease of maintenance\\nAs hosting complexity is reduced, the task of maintaining the website also becomes easier. The server administrator does not need to constantly monitor pre-generated content delivered from a static hosting system or CDN.\\n\\nHaving done all the necessary work prior to deployment, your website will be very stable. Jamstack spares you the hassle of patching, updating, and maintaining your server.\\n\\n#### Portability\\nWebsites built on Jamstack generate static HTML as the final step. This means that you don\'t have to choose a hosting service. With many static hosting services to choose from, Jamstack frees you from vendor lock-in.\\n\\n#### DX (developer experience)\\nA wide variety of existing frameworks and tools can be used to build a Jamstack. Many of them are open source and don\'t rely on commercial software. Therefore, it isn\'t hard to find developers for your Jamstack website. Any Jamstack-building skills can also be applied to other projects.\\n\\n#### Cost\\nWhen running a website using a CMS or similar system, you typically have three or more servers: a web server, an application server, and a database server. The number of servers increases with backup or multiple units, and so does the operational cost.\\n\\nJamstack greatly reduces your cost with the use of static hosting services, CDNs, and dynamic content delivery.\\n\\n#### SEO\\nGoogle currently ranks websites based on page speed, and starting from June 2021, Core Web Vitals will also be included as a ranking metric. With its high-speed content delivery, Jamstack is optimal for SEO. And although the dynamic parts of your site may not be the most SEO-friendly, this is not a huge problem, as Google can interpret the JavaScript code.\\n\\n## Disadvantages\\n#### Technology stack requirements\\nImplementing Jamstack requires a technology stack made up of JavaScript, static site generators, APIs, CDNs, and other pieces. Developers who are not familiar with these technologies have a lot to learn.\\n\\nNevertheless, apart from the optimization generator, the other technologies are all pre-requisites for conventional web building and applications. In any case, they are not difficult to master.\\n\\n#### Build time\\nJamstack generates (i.e., pre-renders) static HTML when deployed. If you have a lot of content, this will take some time. While the build time for a few pages is negligible, 10,000+ pages could take 10 minutes or more.\\n\\nFor example, the static site generator Gatsby has a feature called \\"Incremental Builds\\" that only regenerates pages that have changed. Adopting a static site generator can reduce your build time.\\n\\n#### Man-hours for website modification\\nWith a dynamic CMS, you can generate the text and content in the admin panel. A non-technical operator can easily re-organize or edit the text. However, with Jamstack, you may need to modify and re-deploy the template to make such changes.\\n\\nYou can reduce the developer man-hours by making the operator-modifiable parts into dynamic content. To do so, you need to determine which parts are static and which are dynamic, and devise ways to reduce the operational load for your staff.\\n\\n## Kuroco, the Enterprise Headless CMS\\n\\nFor Jamstack projects in the enterprise space, we hope you will give Kuroco a try - particularly if your business is focused on having a robust API management strategy for multiple frontends.  Our headless CMS comes with all the features you will need to get your Jamstack project up and running, and can be used by technical and non-technical users alike.\\n\\nYou can get started today and test it out for free, or feel free to [reach out to our customer support team](https://kuroco.app/docs/about/support/) if you have any questions!"},{"id":"api-management","metadata":{"permalink":"/blog/api-management","source":"@site/blog/api-management.md","title":"API Management","description":"A brief introduction to API Management","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":3.205,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"API Management","description":"A brief introduction to API Management","slug":"api-management","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"Pros and Cons of Jamstack","permalink":"/blog/pros-and-cons-of-jamstack"},"nextItem":{"title":"Common Patterns for Microservices","permalink":"/blog/common-patterns-for-microservices"}},"content":"A brief introduction to API Management\\n\\n\x3c!-- truncate --\x3e\\n\\n<img src=\\"/files/user/img/blog/Kuroco_API_Centric_Design.svg\\" alt=\\"API Management Design\\"/>\\n\\n## Overview\\n\\nAPI Management is the process of planning, building, testing, and analyzing the single or multiple application programming interfaces (APIs) that connect the outside world with your backend databases, in a secure and manageable environment. In general, API Management is the method that companies employ to transform their existing data into microservices to be consumed by their own applications, or sold as a data service to third-parties.\\n\\n## API Gateways\\n\\nAPI gateways are the most important part of modern API management, functioning as an orchestration layer between the client and the many microservices it is connected with. The main purpose of an API gateway is to handle all the routing, composition, and protocol transformations of data requests made by the client. It also handles security (in particular the authentication and authorization of requests made to the backend).\\n\\nMany (but not all) API gateways also handle data aggregation - or the joining of data fetched from multiple microservices into a single output to be consumed by the client.\\n\\nAPI gateways are important for modern software development, which is now highly dependent on the consumption of microservices. In a smaller application, where only a few microservices are consumed, an API gateway may not be necessary. But as an app scales, and the number of microservices increases, it is imperative to have an orchestration layer to handle this complexity.\\n\\n## API Management Best Practices\\n\\nOnce an API is open to the public, other developers may incorporate it into their own systems as a dependency. For this reason it is important, as a matter of public trust, to always ensure your public APIs are well managed and maintained with proper version control.\\n\\n### Follow Documentation\\n\\nAny platform offering API Management features should provide developers with comprehensive API documentation.\\n\\n### Offer REST for Public APIs\\n\\nAPIs can come in different protocols (ex. REST, GraphQL, SOAP), but the best choice for public APIs is usually REST - as this is the universal standard.\\n\\n### Follow REST API Naming Conventions\\n\\nAPIs can come in different protocols (ex. REST, GraphQL, SOAP), but the best choice for public APIs is usually REST - as this is the universal standard.\\n\\n### Lifecycle Management\\n\\nLifecycle management is the process of building, testing, onboarding, managing and eventually retiring your APIs. Managing this lifecycle internally can be challenging without a dedicated backend team, unless a professional API Management platform is used.\\n\\nIt is crucial that API development is properly managed every step of the way, while practicing proper version control.\\n\\n### Reporting and Analytics\\n\\nIn order to measure the effectiveness of your APIs, it is necessary to know and track the availability, response time, and overall health of each API.\\n\\n* The recording of analytics data relating your APIs can be automated over time\\n* Integration issues can be diagnosed and troubleshooted\\n* Your enterprise can use this data to make better informed decisions regarding its applications and services\\n\\n## API Management with a Headless CMS\\n\\nThe main purpose of a headless CMS is to serve content to different frontends via API. It is therefore no surprise that API management is integral to how a headless CMS functions.\\n\\nNevertheless, not all headless CMSs provide a granular way to manage your content data. Furthermore, other common microservices that are commonly needed by enterprises are not always included in headless CMSs out of the box, and may require custom work by backend developers.\\n\\n## Kuroco, the Enterprise Headless CMS\\n\\nUnlike other headless CMSs available on the market today, Kuroco has robust API Management functionality available to developers out of the box.\\n\\n## Related Articles\\n\\n* [API Gateway vs Backend For Frontend](/blog/api-gateway-vs-backend-for-frontend)\\n* [Common Patterns for Microservices](/blog/common-patterns-for-microservices)\\n* [What is a Progressive Web App?](/blog/what-is-a-progressive-web-app)\\n* [What is the Backend to Frontend Pattern?](/blog/what-is-the-backend-to-frontend-design-pattern)"},{"id":"common-patterns-for-microservices","metadata":{"permalink":"/blog/common-patterns-for-microservices","source":"@site/blog/common-patterns-for-microservices.md","title":"Common Patterns for Microservices","description":"Common Patterns Found Within Microservices Architecture","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":5.975,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"Common Patterns for Microservices","description":"Common Patterns Found Within Microservices Architecture","slug":"common-patterns-for-microservices","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"API Management","permalink":"/blog/api-management"},"nextItem":{"title":"Headless CMS for Jamstack","permalink":"/blog/headless-cms-for-jamstack"}},"content":"Common Patterns Found Within Microservices Architecture\\n\\n\x3c!-- truncate --\x3e\\n\\n## Table of Contents\\n\\n* Overview\\n* Direct Client-to-Microservice Communication\\n* The API Gateway Pattern\\n* Gateway Offloading\\n* Backend for Frontend (BFF)\\n* Kuroco API Management\\n\\n## Overview\\n\\nMicroservices are a type of application architecture that break down an application into multiple service components, in contrast with a traditional monolithic architecture where all the parts are bound together, and sharing dependencies.\\n\\nA microservice exposes fine-grained endpoints, which function independently of other microservices.  The goal is to make each service simpler to build and maintain, reduce dependencies, and increase the speed and scalability of the microservices.  As applications grow in complexity, communicating with many bundled microservices can cause issues, which are discussed below.\\n\\n## Direct Client-to-Microservice Communication\\n\\nThe most basic pattern is direct client-to-microservice architecture. In this pattern, a client application makes direct requests to the microservices.\\n\\nLarger server-side applications are typically organized as a cluster, with load balancing required to manage requests from the client to the proper backend microservices.  As the application grows, this can become more difficult to manage, as the number of microservice types it uses may number in the dozens.\\n\\nIt is therefore important for larger applications to minimize the number of requests to backend microservices, as this can increase latency and result in poor performance on the frontend UI side.  Rather, responses should be bundled on the server side and served to frontend when the required data is aggregated.\\n\\nThe other major issue with the direct client-to-microservices pattern is handling functionality like authorization, transforming of data, and dispatching dynamic requests.\\n\\n* If authorization is required for every microservice individually, this can create a lot of development overhead and repeated code, which is difficult to manage at scale.\\n* If microservices are using protocols not meant for Internet clients to consume directly, they must first be converted to HTTP/HTTPS, which can also require a lot of development overhead.\\n* Bundling API microservices to meet the specific needs of different frontends, like mobile apps versus web browsers\\n\\n## The API Gateway Pattern\\nIn the above pattern, client applications would become coupled with many microservice endpoints over time.  If the application were to change its structure or introduce new microservices, it would quickly become unwieldy to handle so many endpoints.\\n\\n* Coupling:  Although microservices are independent of each other, client applications often make direct reference to internal microservices, which can cause breaking changes if the internal microservices are refactored.\\n* Latency: If any of the client application\u2019s views require many calls to multiple services, this can bog down the network and greatly increase latency. Aggregation is the most obvious solution for this.\\n* Security: Microservices are publicly available by default, making the attack surface larger than if internal microservices not directly used by the client apps are hidden. \\n* Authorization: Publicly available microservice each need to handle cross-cutting concerns such as authorization and SSL. This results in development overhead and repeated code for each microservice, which could be consolidated.\\n\\nThe most widely used solution for the above issues is an API Gateway.\\n\\n## API Gateway\\n\\nThe API Gateway pattern is about placing the needs of the client app first.  It sits between the client application and the microservices, acting as a reverse proxy, routing requests from clients to services. It can also handle functionality like authentication, SSL termination, and caching.\\n\x3c!--- [Insert \u2018Using a single custom API Gateway\u2019 image] --\x3e\\n\\nAn API Gateway can offer various features, including reverse proxy or gateway routing, to redirect or route requests to the endpoints of the internal microservices. The gateway provides a single endpoint or URL for the client applications, internally mapping the requests to a group of internal microservices. This routing feature helps to decouple the client apps from the microservices but it\'s also convenient when modernizing a monolithic API by sitting the API Gateway in between the monolithic API and the client apps, then you can add new APIs as new microservices while still using the legacy monolithic API until it\'s split into many microservices in the future. \\n\\nBecause of the API Gateway, the client apps won\'t notice if the APIs being used are implemented as internal microservices or a monolithic API and more importantly, when evolving and refactoring the monolithic API into microservices, thanks to the API Gateway routing, client apps won\'t be impacted with any URI change.\\n\\n### Requests aggregation\\nAs part of the gateway pattern you can aggregate multiple client requests (usually HTTP requests) targeting multiple internal microservices into a single client request. This pattern is especially convenient when a client page/screen needs information from several microservices. With this approach, the client app sends a single request to the API Gateway that dispatches several requests to the internal microservices and then aggregates the results and sends everything back to the client app. \\n\\nThe main benefit and goal of this design pattern is to reduce chattiness between the client apps and the backend API, which is especially important for remote apps, like mobile apps or requests coming from SPA apps that come from JavaScript in client remote browsers. For regular web apps performing the requests in the server environment, this pattern is not so important as the latency is very much smaller than for remote client apps.\\n\\nDepending on the API gateway you use, it might be able to perform this aggregation. However, in many cases it\'s more flexible to create aggregation microservices under the scope of the API gateway.\\n\\n## Gateway Offloading\\n\\nDepending on the features offered by your API gateway, you can offload functionality from individual microservices to the gateway, which simplifies the implementation of each microservice. \\n\\nThis approach works well for specialized features that can be complex to implement properly in every internal microservice, such as the following functionality:\\n\\n* Authentication and authorization\\n* Service discovery integration\\n* Response caching\\n* Rate limiting and throttling\\n* Load balancing\\n* Logging, tracing, correlation\\n* Headers, query strings, and claims transformation\\n\\n## Backend for Frontend (BFF)\\n\\nSimilar to the API gateway pattern, the Backend for Frontend (BFF) pattern instead uses multiple gateways - each on dedicated to a specific frontend channel.  For example, a native mobile app front and a traditional desktop browser web app would each have an API gateway they integrate, which would in turn aggregate and serve the required data in an appropriate format.\\n\\nFor more information on this pattern, see [this article](/blog/what-is-the-backend-to-frontend-design-pattern/).\\n\\n## Kuroco API Management\\n\\nKuroco\u2019s backend offers API gateway functionality out of the box, with built-in tracking and analytics.\\n\x3c!--- [insert illustration of API Management for Kuroco\u2019s API Gateway] --\x3e\\n\\nKuroco allows for logging, security, and metering of your API.  These insights can help your enterprise get a better understanding of how your APIs are being used and how they are performing. They do this by letting you view near real-time analytics reports and identifying trends that might impact your business. In addition, you can view logs about request and response activity for further online and offline analysis.\\n\\nYou can get started today and test it out for free, or feel free to reach out to our [customer support team](https://kuroco.app/docs/about/support/) if you have any questions!"},{"id":"headless-cms-for-jamstack","metadata":{"permalink":"/blog/headless-cms-for-jamstack","source":"@site/blog/headless-cms-for-jamstack.md","title":"Headless CMS for Jamstack","description":"An overview on how a headless CMS can be used for a Jamstack projects","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":3.035,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"Headless CMS for Jamstack","description":"An overview on how a headless CMS can be used for a Jamstack projects","slug":"headless-cms-for-jamstack","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"Common Patterns for Microservices","permalink":"/blog/common-patterns-for-microservices"},"nextItem":{"title":"Headless CMS","permalink":"/blog/headless-cms"}},"content":"An overview on how a headless CMS can be used for a Jamstack projects\\n\\n\x3c!-- truncate --\x3e\\n\\n## Table of Contents\\n\\n* Overview\\n* Do I Really Need a Headless CMS for My Jamstack Project?\\n* Key Benefits of a Headless CMS for Jamstack\\n* Which Headless CMS Should I Choose?\\n* Kuroco, the Enterprise Headless CMS\\n\\n## Overview\\nAs a relatively new technology stack, Jamstack projects inherently require some technical knowledge to get up and running.  In the beginning, it was mainly full-stack or frontend developers making use of Jamstack to publish their own blogs and personal websites, without having to maintain a complicated backend or manage their own servers.\\n\\nAs the Jamstack ecosystem has grown over the years and become more mainstream, larger enterprises are now making use of this technology.  As with any web technology used by businesses, this means that content creation is very important, with non-technical content creators and marketers being key stakeholders.\\n\\nThe easiest way to open up your Jamstack project for content creators is by using a headless CMS.\\n\\n## Do I Really Need a Headless CMS for My Jamstack Project?\\n\\nThe simple answer is that no, you do not necessarily *need* a headless CMS, particularly if your project is very small (ex. only a few pages).  However, if you have any non-technical writers who will be managing content regularly, then a headless CMS is highly recommended - as without it they will need to edit the source files directly (assuming they even have access to that).\\n\\n## Key Benefits of a Headless CMS for Jamstack\\n\\n* **Ease of use:**  For non-technical users, the headless CMS provides an easy to understand interface, making creation and editing of their content a breeze.  The alternative is to have them login to the Git-based repository where the source files are located, and push any changes they make to those files (a situation that would likely result in confusion, or worse, if they accidentally push any breaking changes).\\n\\n* **Security:** As mentioned above, giving non-technical users access to source files in the repository is rarely a good idea.  Even if they understand which files to edit, accidents could happen - and the more people who access to source files, the more likely that security vulnerabilities could be exploited.\\n\\n* **Improved content creation workflows:** With a headless CMS, the content creation is decoupled from the site\'s development.  Writers can produce content in the CMS, without having to create changes directly in the source files (which would have to be reviewed and deployed each time by the developer/webmaster).\\n\\n## Which Headless CMS Should I Choose?\\n\\nThere are many \'headless\' CMS options available on the market today, catering to different needs and budgets.  For Jamstack projects, a headless CMS that is easily configurable is recommended (not all headless CMS are focused on Jamstack).\\n\\nIn terms of free options, most static site generators have headless CMSs available, but tend to target the lower end of the market, i.e. smaller projects that do not require much in the way of role-based permissions or team collaboration.\\n\\n## Kuroco, the Enterprise Headless CMS\\n\\nFor Jamstack projects in the enterprise space, we hope you will give Kuroco a try - particularly if your business is focused on having a robust API management strategy for multiple frontends.  Our headless CMS comes with all the features you will need to get your Jamstack project up and running, and can be used by technical and non-technical users alike.\\n\\nYou can get started today and test it out for free, or feel free to [reach out to our customer support team](https://kuroco.app/docs/about/support/) if you have any questions!"},{"id":"headless-cms","metadata":{"permalink":"/blog/headless-cms","source":"@site/blog/headless-cms.md","title":"Headless CMS","description":"A brief introduction to Headless CMS","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":6.345,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"Headless CMS","description":"A brief introduction to Headless CMS","slug":"headless-cms","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"Headless CMS for Jamstack","permalink":"/blog/headless-cms-for-jamstack"},"nextItem":{"title":"Jamstack and Serverless","permalink":"/blog/jamstack-and-serverless"}},"content":"A brief introduction to Headless CMS\\n\\n\x3c!-- truncate --\x3e\\n\\n<img src=\\"/files/user/img/blog/Kuroco_Headless_Overview.svg\\" alt=\\"Kuroco Headless Overview\\"/>\\n\\n## What is a Headless CMS?\\n\\nA content management system (CMS) is a type of software tool that allows non-technical users to easily create and manage the content of their website or application, stored as data on a backend content repository (database).\\n\\nA \'headless\' CMS provides the same functionality as a traditional CMS, while decoupling the backend data from the frontend, and exposing it via \'application programing interfaces\' (APIs). These APIs are typically RESTful or GraphQL, and can be consumed by any frontend on any device.\\n\\nIn other words, the concept of a CMS being \u201cheadless\u201d comes from separating or decoupling the frontend code (\\"head) from the backend code (\\"body\\"). In traditional CMSs the frontend and backend code are usually coupled; with a \\"headless\\" CMS any frontend can be used for presenting the content/data from the backend.\\n\\n## Headless CMS vs Traditional (\u2018Coupled\u2019) CMS\\n\\nSince a headless CMS is able to serve decoupled API data, this content can be easily consumed on any browser type on virtually any device, making it suitable for omnichannel websites and applications.\\n\\nIn traditional CMSs (in use for decades), the backend data is tightly coupled with the HTML code that is served to the frontend layer. This makes it very difficult to use the data outside of the templates custom built for that CMS.\\n\\n## Features of a traditional CMS:\\n\\n* Interface enabling users to create and edit read/write data (content).\\n* Database to store read/write data.\\n* Role based access control, typically with an admin panel to grant user permission for managing the content.\\n* Frontend presentation layer (i.e. the actual website that people can see), with the content data mixed into the code.\\n\\nIn web development, the best known traditional CMS platforms include WordPress, Drupal, as well as low or no code website editor options like Wix and Squarespace. In each of these platforms, the frontend presentation layers are tightly coupled with the backend data, which cannot usually be exported to other channels outside the platform.\\n\\nWhile traditional CMSs worked well in the past, the near ubiquitous use of mobile and other smart devices, the rise of omnichannel marketing, and the shift toward more progressive frontend web frameworks (like React, Vue, and Angular) require a more flexible and performant approach for serving content data.\\n\\n## When Should You Consider Using a Headless CMS?\\n\\nAny enterprise that wants to unlock the power of its data should consider using a headless CMS. Websites and applications built on legacy technology stacks may have a lot of data stored in a database, but if this data is only used for a single frontend view (ex. desktop web browser), it is not being used to its full potential.\\n\\nIn particular, if your company\u2019s frontend developers are responsible for building modern UI/UX views that work not only on desktop web browsers, but also on mobile and other devices, they will need access to this data in the form of a modern API.\\n\\nIn order to avoid disruptions for the content creators and marketers on other teams, this data should also be manageable in a non-technical content management interface - which is where a headless CMS comes into play.\\n\\n## How a Headless CMS can Increase Your Digital Agility\\n\\nDigital agility is the ability of organizations to rapidly develop, test, and ship new systems and processes.\\n\\nIn the case of an enterprise website or application, there are usually multiple teams working on projects with many dependencies.\\n\\nFor example, many modern frontend websites and applications are now built with next-generation JavaScript frameworks like React and Vue. Frontend teams need to iterate rapidly to build UI/UX designs that meet user needs. If the frontend and backend data are tightly coupled, then any data changes requested from the frontend team could result in breaking changes on the backend.\\n\\nBackend teams are generally more concerned with reliability, security, and overall performance. If they have to work closely with frontend teams to ensure that tightly coupled data is being served to meet the frontend\'s needs, this can result in long and costly delays in development.\\n\\nA decoupled API solves this problem - ensuring that frontend teams can consume the data without having to change any of the backend code. This separation of concerns greatly increases productivity, leading to far fewer bugs during development and faster time to launch.\\n\\n### Technology Agnostic Frontends\\n\\nFrontend developers can also choose any technology they want to work with, without having to worry about any framework bugs that might crop up in stacks used by other frontend teams. For example, one team might be using a React Native library for a mobile app, and another might be using a static site generator for a desktop site - both consuming the same data from the backend API, but without any conflicting dependencies.\\n\\n### The Rise of Jamstack Sites\\n\\nOften the newer progressive Javascrip frameworks (React, Vue, etc.) are used to build Jamstack websites. The advantage to this method is improved performance (esp. page loading speed) and better security compared to sites built on traditional coupled CMSs.\\n\\nFor more information on Jamstack, check out this [related article](/blog/jamstack).\\n\\n## How Should You Host Your Headless CMS?\\n\\nThere are various options for hosting a headless CMS. Open source options are available, but will require backend developers to manage the hosting and maintenance on your internal systems (or cloud infrastructure that you pay for). Alternatively, services that offer paid backend cloud hosting are available (usually at a low cost)\\n\\n## Kuroco Headless CMS\\n\\nKuroco is a heavily API-focused headless CMS that makes it easy to configure endpoints for different frontends. This flexibility makes our platform\'s API management a similar solution to the [\'backend-for-frontend\' (BFF)](/blog/what-is-the-backend-to-frontend-design-pattern) model, enabling more granular queries for different frontends.\\n\\nFor more information on Kuroco, and how it can be a great fit for your online business, check out our comprehensive [documentation site](https://kuroco.app/docs/).\\n\\n## Common Headless CMS Use Cases\\n\\n* **Progressive Web Apps:** Built with next-generation Javascript libraries like React/Next.js, Vue/Nuxt.js, Angular, etc.\\n* **Native Mobile Apps:** Native apps built for iOS (Swift), Android (Java), and/or Windows Phone (C#)\\n* **E-commerce:** Simplified content creation on websites built with popular e-commerce backends like Shopify, Magento, Bigcommerce, or Jamstack solutions like Snipcart.\\n* **Static Site Generators:** Manage content on popular SSG frameworks like Jekyll, Hugo, Gatsby, and Gridsome\\n* **Overall API Management:** While not all headless CMSs have advanced API customization functionality built-in, platforms like [Kuroco](https://kuroco.app/) can make this process a breeze.\\n\\n## Summary\\n\\nWhile different companies have different needs and use cases for various CMS options available on the market today, the overall trend continues toward the \'headless\' approach. The advantages of decoupling your data from a single frontend view, and opening it up to be more securely used by any number of independent frontends are simply undeniable.\\n\\nYou can greatly increase your business\'s productivity, free up you frontend team to more rapidly build and test their UI/UX designs, and make it easy for non-technical content creators and marketers to manage their content.\\n\\nWe hope you will give Kuroco a try - particularly if your business is focused on having a future-proof API management strategy. You can [get started today](https://kuroco.app/free_trial/) and test it out for free, or feel free to check out our site to learn more information!\\n\\n<img src=\\"/files/user/img/blog/Kuroco_Headless_CMS.svg\\" alt=\\"Kuroco Headless CMS\\"/>\\n\\n## Related Articles\\n\\n* [A Guide to Choosing an Enterprise Headless CMS](/blog/guide-to-choosing-an-enterprise-headless-cms)\\n* [Git-based Vs API-centric Headless CMS](/blog/git-based-vs-api-centric-headless-cms)\\n* [What Are the Benefits of a Headless CMS?](/blog/what-are-the-benefits-of-a-headless-cms)\\n* [Why is a Headless CMS Important for Enterprises?](/blog/why-is-a-headless-cms-important-for-enterprises)"},{"id":"jamstack-and-serverless","metadata":{"permalink":"/blog/jamstack-and-serverless","source":"@site/blog/jamstack-and-serverless.md","title":"Jamstack and Serverless","description":"A description of how the Jamstack and Serverless ecosystems are interrelated","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":4.425,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"Jamstack and Serverless","description":"A description of how the Jamstack and Serverless ecosystems are interrelated","slug":"jamstack-and-serverless","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"Headless CMS","permalink":"/blog/headless-cms"},"nextItem":{"title":"Jamstack for Enterprise","permalink":"/blog/jamstack-for-enterprise"}},"content":"A description of how the Jamstack and Serverless ecosystems are interrelated\\n\\n\x3c!-- truncate --\x3e\\n\\n<img src=\\"/files/user/img/blog/Kuroco_Tap_Into_Power_Serverless_Functions.svg\\" alt=\\"serverless functions\\" width=\\"300\\"/>\\n\\n## Table of Contents\\n* Overview\\n* How it Works\\n* Examples of Serverless Functions Used in Jamstack\\n\\n## Overview\\n\\nIn an era of internet buzzwords, it can be difficult to keep track of the latest technology trends and how they compare.  In recent years, two of the most popular new technologies to emerge have been the Jamstack, and Serverless architecture.\\n\\nThe Jamstack is a next-generation frontend focused web development stack.  The name stands for: JavaScript, APIs, and Markup. Its goal is to make websites and apps easier and cheaper to host and serve to clients, while simplifying the overall development process.\\n\\nServerless architecture is closely related to the Jamstack, but is a separate and more expansive ecosystem unto itself.  As the name implies, \'serverless\' architecture essentially replaces the need for developers to manage a complicated backend by themselves.  In reality, servers are of course still being used behind the scenes, but the backend cloud services they provide allow developers to skip having to setup or maintain their own servers.\\n\\n## How it Works\\n\\nTypically, when a front-end application is built, developers will need to connect it to a backend system (usually built in Ruby-on-Rails, PHP, Node.js, or other backend languages). This backend will serve up functions needed to power the frontend, particularly when fetching data and for authorizing/authenticating requests.  \\n\\nIn serverless architecture, these functions are handled automatically by the cloud service provider.  The system resources are already set up and available, and can auto-scale with demand from the frontend.  One of the main appeals of using serverless functions in this way, is that sudden spikes in traffic to your website will automatically be provision for by the serverless infrastructure.  Moreover, you will only pay for the number of functions that are called, without having to pay for constant server uptime.\\n\\nThis functionality is key for running effective Jamstack projects.  Frontend developers can focus on building out their application\'s UI, and the backend functionality is taken care of for them by the serverless systems.\\n\\nOne issue to be aware of is that on some cloud platforms unused serverless functions may be set to \u2018idle\u2019 and require a \u2018cold start\u2019 when used again, which can result in slightly slower reaction speeds. This issue does not occur if the application and its functions are being used regularly.\\n\\n## Examples of Serverless Functions Used in Jamstack\\n\\n* **Making API calls to fetch data server-side,** before serving the static HTML files to the browser. While Jamstack is often associated with serving static sites from a CDN, it is possible to add dynamic functionality using serverless functions.\\n\\n* **Handling authorization.** While it is possible to store JSON web tokens (JWTs) in the browser, it is still necessary to generate the bearer tokens server-side (they cannot be stored in the browser due to obvious security vulnerabilities). Rather than building out your own backend server for this, it can be handled by the host using serverless functions.\\n\\n* **Contact Forms or Email Notifications.** Handling forms (ex. a user enters their name, email, and message, and submits it - which would cause that information to be emailed to you) directly on a static site can require a lot of JavaScript overhead that could make the page bulky and more expensive to load in the user\u2019s browser. Instead, that functionality can be put into a serverless function, run on the host in the serverless backend, and triggered by the user\u2019s action on the front-end.\\n\\n## Is Jamstack/Serverless Right for My Business?\\n\\nBoth of these technologies are well-established, and used by the largest enterprises in the world.  However, whether or not they are suitable will depend on the requirements of a given project.\\n\\nServerless architecture is widely used, with platforms like AWS (Lambda functions) powering much of the Internet today.  Companies that already have large amounts of internal server resources provisioned may not need to use such services; but the ease of use and low cost of using serverless functions makes it an attractive option, particularly for new projects or when building out a proof-of-concept.\\n\\nJamstack has more limited use cases, but has similar trade-offs.  When building out complex applications with a lot of dynamic functionality, it may be better to lean more heavily on server-side functionality.  Static pages rely more on the browser run-time environment, which is not always ideal.  For fast, highly performant websites serving static content, Jamstack is an excellent choice.\\n\\n## Combining Serverless/Jamstack Projects with a Headless CMS\\n\\nA good headless CMS will come with a lot of backend functionality built in, including access to serverless functions, and static hosting for Jamstack sites.  While this also be achieved without a CMS, it usually makes sense to have an interface for content creators, marketers, and other non-technical stakeholders to make use of.\\n\\nKuroco, the enterprise headless CMS, was built with serverless architecture in mind, and can easily host Jamstack websites on our CDN.  If you\'re looking for an enterprise grade solution to host your serverless and/or Jamstack projects, we hope you will give Kuroco a try!\\n\\nYou can get started today and test it out for free, or feel free to [reach out to our customer support team](https://kuroco.app/docs/about/support/) if you have any questions!"},{"id":"jamstack-for-enterprise","metadata":{"permalink":"/blog/jamstack-for-enterprise","source":"@site/blog/jamstack-for-enterprise.md","title":"Jamstack for Enterprise","description":"How can the Jamstack be effectively used by enterprises","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":5.37,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"Jamstack for Enterprise","description":"How can the Jamstack be effectively used by enterprises","slug":"jamstack-for-enterprise","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"Jamstack and Serverless","permalink":"/blog/jamstack-and-serverless"},"nextItem":{"title":"Jamstack","permalink":"/blog/jamstack"}},"content":"How can the Jamstack be effectively used by enterprises\\n\\n\x3c!-- truncate --\x3e\\n\\n## Table of Contents\\n* Jamstack Overview\\n* Jamstack for Enterprises\\n* Using the \u2018Microsites\u2019 Pattern\\n* Is it Difficult to Migrate to Jamstack as an Enterprise?\\n* Main Benefits of Jamstack for Your Enterprise\\n* Kuroco Is Built with Enterprise-Grade Projects in Mind\\n\\n## Jamstack Overview\\n\\nIn its inception, the Jamstack was an innovative web stack used mainly by frontend developers to publish their own personal sites or blogs cheaply, while maximizing performance.  The ability to publish static pages, hosted on CDNs, meant that developers could save money on hosting and not have to set up or manage servers.\\n\\nSince that time, the Jamstack has matured into a well-developed ecosystem, used by companies both large and small, with many use cases suitable for large enterprises.\\n\\n## Jamstack for Enterprises\\n\\nIt is commonly assumed that large enterprise applications need to be built atop complex backend systems.  However, as microservices patterns and [serverless architecture](/blog/serverless) have become ubiquitous in the industry, frontend solutions have become decoupled and much more flexible to deploy.\\n\\nWhile Jamstack was originally used primarily by frontend developers to publish static websites and blogs, modern API management and JavaScript libraries make it easy for static frontends to consume and display dynamic data without requiring expensive page reloads on the server side.\\n\\nOne of the main challenges with using Jamstack for enterprise sites has been the requirement to run a build command to pre-render all the pages from a JavaScript library like React or Vue, which could comprise many thousands of pages for some larger sites.  This can result in slow and more expensive build times.\\n\\nFor this reason, incremental builds have become more popular, along with splitting very large sites into smaller sections, and only publishing updated pages at build time (instead of re-rendering the entire site each time a new page is created, or a small change made to one of the existing pages).\\n\\n## Using the \u2018Microsites\u2019 Pattern\\n\\nThe easiest way to cut down on build time overhead is to break down your enterprise site into smaller, logical sections, tied back to the site\u2019s route domain using proxies or redirects (ex. for subdomains).  A site will typically be divided into several sections, using a navigation bar for main pages.  Each of these main pages can be treated as a separate microsite, which in turn can be further subdivided into additional microsites as needed.\\n\\nIf certain sections are managed by different content creators, they can each publish their contents to their respective microsites, run a build command, and deploy their content without affecting other sections or content managed by other teams.\\n\\n### Generate Only Necessary Pages at Run-Time\\n\\nIt is possible to delay the generation of rarely used pages (ex. pages containing legal content or technical information that are rarely visited) until after the main pages of the site have been generated and deployed to the CDN.\\n\\n### Incremental Builds\\n\\nSome modern static site generators (like Gatsby, built with React.js) are able to trigger partial rebuilds that only affect new or altered content added to the site, without having to rebuild the pages that have not been changed.  This can make a huge difference in reducing build time and keeping site availability higher.\\n\\n## Is it Difficult to Migrate to Jamstack as an Enterprise?\\n\\nTraditionally, when large enterprise platforms want to upgrade their software, this would entail a lot of planning, risk assessment, and development resources to achieve a migration.  In the case of Jamstack, this is really not the case.  The overarching philosophy behind the Jamstack is similar to that of a \u2018headless CMS\u2019 - the frontend and backend concerns are decoupled.\\n\\nSince Jamstack is powered by APIs, there is no real need to adjust your existing backend systems at all.  As long as your existing microservices architecture is able to offer an API (or API Gateway) then you can build standalone Jamstack sites or pages immediately.  This process can be done incrementally - with the goal of eventually replacing your existing frontend - or as one-off projects.  Jamstack is highly flexible.\\n\\nA typical approach would be to roll out a Jamstack microsite for a section of your existing main site, and redirect traffic to it (this is easy to do).  This microsite can be tested and optimized for performance, with minimal disruption, with additional microsites built out over time.\\n\\n## Dynamic Content in Jamstack Pages?\\n\\nA common misconception is that since Jamstack is based on serving up pre-rendered static HTML files, it cannot dynamically display content.  In fact, the \u2018J\u2019 in the Jamstack acronym stands for \u2018JavaScript\u2019 - meaning that these static pages still contain scripts that can fetch and post data.\\n\\n### Targeted and Personalized Content for Users\\n\\n* Universal content is available via the standard build process, served up to users on the edge node closest to them on the CDN.\\n* Localized content can be handled by building local versions of pages and routing them to users based on their geography.\\n* Targeted and personalized content can be delivered by having user accounts and auth - this typically handled by headless CMS platforms (like Kuroco), which will populate pages with content from APIs.\\n\\n## Main Benefits of Jamstack for Your Enterprise\\n\\nOne of the main reasons that Jamstack works well as an enterprise solution is: scalability.  Since cloud-based solutions like CDNs are inexpensive, highly available, secure, and performant, Jamstack assets can be deployed quickly without any need for complicated backend management.\\n\\n**Jamstack offers many security advantages over traditional coupled CMS platforms like WordPress or Drupal.**\\n\\nJamstack pages are often much more performant than pages built on older stacks (unless properly optimized, which is often not the case).  This is particularly important for audiences consuming your web content on their mobile devices, as slow load times result in a poor user experience, which can greatly increase \u2018bounce rates\u2019, and negatively impact your marketing efforts with your online content.\\n\\n## Kuroco Is Built with Enterprise-Grade Projects in Mind\\n\\nKuroco, the enterprise headless CMS, has all the serverless infrastructure your enterprise project would need to be highly scalable, secure, and performant.\\n\\nKuroco also allows you to [configure your API](/blog/api-management) with different paths containing different microservice endpoints for each frontend you have.\\n\\nYou can get started today and test it out for free, or feel free to [reach out to our customer support team](https://kuroco.app/docs/about/support/) if you have any questions!"},{"id":"jamstack","metadata":{"permalink":"/blog/jamstack","source":"@site/blog/jamstack.md","title":"Jamstack","description":"A brief introduction to Jamstack","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":7.82,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"Jamstack","description":"A brief introduction to Jamstack","slug":"jamstack","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"Jamstack for Enterprise","permalink":"/blog/jamstack-for-enterprise"},"nextItem":{"title":"Serverless","permalink":"/blog/serverless"}},"content":"A brief introduction to Jamstack\\n\\n\x3c!-- truncate --\x3e\\n\\n<img src=\\"/files/user/img/blog/Kuroco_Jamstack.svg\\" alt=\\"Kuroco Jamstack\\"/>\\n\\n## What is Jamstack?\\n\\nJamstack (or JAMstack) is a frontend web application/architecture that dynamically fetches content as needed and rewrites websites using static HTML as a base. It allows you to design websites that are faster, safer, and easier to extend.\\n\\nThe name \\"Jamstack\\" refers to the technology stack that combines JavaScript, APIs, and pre-rendered Markup, which decouple client-side applications from traditional backend services or any particular web server.\\n\\nThe Jamstack ecosystem was popularized by Netlify in 2015, as a new approach to web development. Leveraging newer Javascript frameworks like Angular, React, and Vue, it became possible to run build commands that would pre-render Javascript files, and compile web pages into static files. These static files, which are much leaner and faster-loading that pages built on the server-side of traditional CMS-driven websites (e.g. WordPress) can be uploaded to content delivery networks (CDNs) and delivered to clients much more quickly, securely, and at a lower cost.\\n\\nThis approach is particularly beneficial for mobile users, as the amount of data required for the first load on the browser of a prerendered Jamstack page is usually a fraction of what is loaded on traditional server-loaded web pages. This greatly improves the user experience, and reduces bounce rates on landing pages.\\n\\n*The 3 main parts that make up the Jamstack are as follows:*\\n\\n### JavaScript\\n\\nDynamic functionality on Jamstack pages is handled by JavaScript, using the browser as the universal runtime layer for your site. JavaScript is also what allows static pages to fetch API data when the page is mounted.\\n\\n### APIs\\n\\nInstead of using the traditional serverside method of fetching data from a database, these operations are now abstracted into APIs that can be called clientside over HTTPS, using JavaScript. As long as the APIs are properly maintained and configured with the necessary endpoints, a Jamstack site can (in theory) run without ever touching a server.\\n\\nIn reality, however, [API gateways](/blog/api-management) are commonly deployed to ensure that only secure requests are made before data is sent to the browser.\\n\\n### Markup\\n\\nHTML markup is the skeleton of the modern web, used to create the document object model (DOM) parsed by browsers. Traditionally, HTML pages are generated by a server and sent to the browser. In Jamstack, pages are prerendered in advance (using a build tool, found static site generators like Gatsby and Gridsome) and stored on a content delivery network (CDN).\\n\\nBecause all the Jamstack pages are served from the CDN as prerendered static assets, there is a much reduced loading time compared to pages loaded from traditional backend servers.\\n\\n## Key Features of Jamstack\\n\\n### Decoupling\\n\\nWebsites built on Jamstack differ from HTML-only sites in that they use JavaScript to communicate with the back-end server and provide dynamic content. Authentication and comment functions, payment, user personalizations, and other areas that generally require dynamic mechanisms are also implemented with JavaScript.\\n\\nThe API economy enables developers to implement functionality without complex server-side development. Jamstack leverages APIs to decouple technical complexity from the risks involved, thereby increasing the flexibility and portability of your websites.\\n\\nThe front end uses tooling separate from the back end. The front end is typically built using a static site generator. And the back end is often integrated with the front through the use of APIs used during the build process. Server-side processes can also be run using serverless functions.\\n\\n<img src=\\"/files/user/img/blog/Kuroco_Jamstack_Decoupling.svg\\" alt=\\"Kuroco Jamstack\\"/>\\n\\n### Static-first\\n\\nWhile various practices exist for introducing dynamic elements to Jamstack sites, most are pre-rendered, which means the front end was built and compiled into HTML, CSS, and JavaScript files.\\n\\n### Pre-rendering\\n\\nMany Jamstack frameworks use special notations and templates, which are then converted into static HTML when deployed as websites. Unlike conventional web development mechanisms that generate HTML in response to user requests, the pre-rendered approach generates assets such as HTML, CSS, JavaScript, and images in advance.\\n\\nUsing a CDN enables such static content to be delivered at high speed.\\n\\nJavaScript can be introduced to pre-rendered sites on an as-needed basis, thus increasing performance in the browser.\\n\\n## Benefits of Jamstack\\n\\n### Faster\\n\\nPre-rendered static pages are able to load lightning-fast, directly in the browser, compared to traditional pages that have to first be generated by a server, and then parsed in the browser.\\n\\nFaster page loading speeds provide a superior user experience. This is particularly important for users on mobile devices, where slow loading pages result in significantly higher bounce rates. Static pages also typically use less data to render.\\n\\n### More Secure\\n\\nSince Jamstack pages are static and decoupled from any backend servers, there is no attack vector for malicious code to work on. This remains true, even if the pages contain JavaScript for fetching data from APIs - as long as the API itself is secure.\\n\\nThis is in contrast to sites built on traditional CMSs like WordPress, where frontend and backend is tightly coupled. These security vulnerabilities are well-known and discussed by [authoritative blogs](https://blog.hubspot.com/website/wordpress-security-issues) online.\\n\\n### Superior Experience for Developers\\n\\nAs the Jamstack ecosystem has continued to grow, the ease with which developers can build websites using popular frameworks like Next.js, Nuxt.js, Gatsby, Gridsome, etc. has increased dramatically. It is possible to build a basic static website in a matter of minutes, and ship it to hosting service like Kuroco, Netlify, or Github Pages.\\n\\nOnce the basic site is up and running, the developer can focus on building out the frontend UI components - without having to worry about the usual issues involved with building out a backend application from scratch.\\n\\n### Less Expensive\\n\\nRelated to the previous point, Jamstack projects require a lot less (or in some cases, zero) support from backend teams. This eliminates a lot of the overhead that is normally required to manage backend servers and databases.\\n\\nAs a project scales, it may be necessary to make use of some backend support (ex. if setting up custom API gateways or other serverless infrastructure), but in nearly all cases this will still be much more cost effective than maintaining a self-hosted backend at scale.\\n\\n## Use Cases\\n\\nIn the beginning, Jamstack was mainly used by developers for publishing their own blogs and websites. The attraction was the ability to run a highly performant site (using the latest JavaScript frameworks), without having to set up servers or maintain a complicated backend.\\n\\nInstead, the backend could be handled by popular [\u2018serverless\u2019](/blog/serverless) frameworks, hosted on cloud providers (including AWS, Google Cloud, or Netlify)\\n\\nSome of the more common use cases for Jamstack include:\\n\\n### Blogging\\n\\nFor any blogger with technical/coding abilities, Jamstack makes a far better (and cheaper) choice than nearly other option.\\n\\nIn the first place, it is possible to host the static pages extremely cheaply (or free) on many services. Paid hosting for other blog platforms using traditional CMSs will be sigificantly costlier.\\n\\nAs discussed above, Jamstack pages are also much faster to load in the browser, meaning readers of your blog will have a better user experience.\\n\\nHowever, the main downside is that without at least some basic technical knowledge, it is unlikely that a non-technical blogger could set up and customize a blog site on their own. Paying a developer to build a Jamstack site, with a [headless CMS](https://kuroco.app/) for the content creator to use and manage their site\'s content is still a reasonable option.\\n\\n### E-commerce\\n\\nThe most common approach for e-commerce remains traditional CMS platforms, like WordPress (using e-commerce plugins). Other paid plaforms like Shopify provide an easy content creation experience.\\n\\nHowever, excellent Jamstack compatible options do exist. Since Jamstack pages are powered by APIs, it is possible to connect them to cloud-based e-commerce services with just a few lines of code. Once the page is mounted, that third-party data will load on the page separately.\\n\\nExamples of Jamstack-related e-commerce services include [Snipcart](https://snipcart.com/), and [Shopify Lite](https://www.shopify.com/starter).\\n\\nIn addition to the e-commerce functionality itself, page content can be managed by marketers using a headless CMS.\\n\\n### Enterprise\\n\\nAs the Jamstack ecosystem continues to grow and improve, the benefits for larger enterprises are becoming apparent. See this related article for more information: [\\"Jamstack for Enterprise\\"](/blog/jamstack-for-enterprise).\\n\\n## Summary\\n\\nJamstack is a next-generation web technology stack that leverages the power of JavaScript frameworks and APIs consumable in the browser, to build leaner, more performant, and more cost effective sites.\\n\\nOne of the most important factors in making a Jamstack viable for a team that includes dedicated content creators and marketers, is having a headless CMS. Kuroco is a headless CMS built with enterprise clients in mind, and is an ideal solution for content-heavy Jamstack projects.\\n\\nWe hope you will give Kuroco a try. You can [get started today](https://kuroco.app/free_trial/) and test it out for free, or feel free to check out [our site](https://kuroco.app/) to learn more information!\\n\\n## Other Resources for Learning About Jamstack\\n\\n### Web links\\n\\n* [Jamstack](https://jamstack.org/) Official website for Jamstack.\\n* [Welcome to The Jamstack](https://www.netlify.com/jamstack/) An introduction by Netlify, a supporter of Jamstack.\\n\\n### Videos\\n\\n* [Jamstack TV - YouTube](https://www.youtube.com/c/JAMstackConf) Official YouTube channel for Jamstack. Includes videos on the annual [Jamstack Conf](https://jamstack.org/conf/) and other related content.\\n* [Jamstack: The Complete Guide | Udemy](https://www.udemy.com/course/jamstack/) Udemy course on web development using Jamstack.\\n\\n## Related Articles\\n\\n* [Differences Between Jamstack and Conventional Websites](/blog/differences-between-jamstack-and-conventional-websites)\\n* [Headless CMS for Jamstack](/blog/headless-cms-for-jamstack)\\n* [Jamstack Architecture](/blog/jamstack-architecture)\\n* [Jamstack for Enterprise](/blog/jamstack-for-enterprise)\\n* [Pros and Cons of Jamstack](/blog/pros-and-cons-of-jamstack)"},{"id":"serverless","metadata":{"permalink":"/blog/serverless","source":"@site/blog/serverless.md","title":"Serverless","description":"A brief introduction to Serverless","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":4.54,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"Serverless","description":"A brief introduction to Serverless","slug":"serverless","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"Jamstack","permalink":"/blog/jamstack"},"nextItem":{"title":"WAF","permalink":"/blog/waf"}},"content":"A brief introduction to Serverless\\n\\n\x3c!-- truncate --\x3e\\n\\n<img src=\\"/files/user/img/blog/Kuroco_Serverless_Web_Api_System.svg\\" alt=\\"Kuroco Serverless\\"/>\\n\\n## Overview\\n\\n\'Serverless\' is a type of cloud-based systems architecture focused on providing ready-to-use, scalable backend resources on demand. Serverless does not mean that no servers are being used (i.e. behind the scenes), but rather that as a developer - particularly one focused on the front-end - you do not need to worry about creating, writing code for, or maintaining a server on the backend.\\n\\nTraditionally, businesses would have to set up and maintain additional servers to keep up with increased demand over time, which is costly and time consuming. With enterprise-grade server clusters available from cloud providers like AWS, Google, Microsoft, and many other companies, backend resources are now widely available for any business to tap into online.\\n\\nWhile serverless is technically a backend solution, its main use case is automating the backend to allow developers to focus more on the frontend.\\n\\n### Serverless Functions\\n\\n\u2018Serverless\u2019 is also the name of a popular open-source framework built in Node.js, which deploys to AWS. The basis of this framework is that frontend applications can be powered by AWS Lambda functions, the largest \u201cfunctions as a service\u201d (FaaS) provider. FaaS providers (including AWS and many others on the market) allow frontend software to use functions similar to what would normally be called server-side (for example, when handling API calls to fetch secure data with a token that cannot be stored in the browser).\\n\\nA serverless framework, combined with FaaS, is potentially a much cheaper solution than running dedicated servers full-time. FaaS usage is only charged per function called, resulting in less overhead during times of low demand.\\n\\n## Jamstack and Serverless\\n\\nThe Jamstack (or JAMstack) stands for: **J**avaScript, **A**PIs, and **M**arkup. This is one of the newer web development stacks, with the goal of making websites and apps easier and cheaper to host and serve to clients, as well as simpler for developers to build.\\n\\nTraditionally, when a front-end application is built, developers will need to connect it to a backend (typically built in Ruby-on-Rails, PHP, Node.js, or other backend languages). With Jamstack, however, front-end developers can instead simply include serverless functions in the source code of their application, and a hosting service provider can handle that functionality (this is considered the \u2018serverless\u2019 way).\\n\\nOnce again, the main advantage to this approach is that these serverless functions can automatically scale up or scale down capacity, depending on usage.\\n\\n### A Note on \'Cold Starts\' with Serverless Functions\\n\\nIn some cases, if a serverless app is unused for an extended period, the FaaS may not respond to requests as quickly as a dedicated server would, but in most cases this is a minor trade-off, with little (or no) effect on performance. For larger apps with high amounts of traffic, the serverless functions will be constantly active and able to scale instantly on demand.\\n\\nOne issue to be aware of is that on some cloud platforms unused serverless functions may be set to \u2018idle\u2019 and require a \u2018cold start\u2019 when used again, which can result in slightly slower reaction speeds. This issue does not occur if the application and its functions are being used regularly.\\n\\n## Examples of Serverless Functions Used in Jamstack\\n\\n- Making API calls to fetch data server-side, before serving the static HTML files to the browser. While Jamstack is often associated with serving static sites from a CDN, it is possible to add dynamic functionality using serverless functions.\\n- Handling authorization. While it is possible to store JSON web tokens (JWTs) in the browser, it is still necessary to generate the bearer tokens server-side (they cannot be stored in the browser due to obvious security vulnerabilities). Rather than building out your own backend server for this, it can be handled by the host using serverless functions.\\n- Contact Forms or Email Notifications. Handling forms (ex. a user enters their name, email, and message, and submits it - which would cause that information to be emailed to you) directly on a static site can require a lot of JavaScript overhead that could make the page bulky and more expensive to load in the user\u2019s browser. Instead, that functionality can be put into a serverless function, run on the host in the serverless backend, and triggered by the user\u2019s action on the front-end.\\n\\n### Where can I host my serverless app?\\nThe biggest cloud providers include AWS, Google Cloud, and Azure, providing mainly infrastructure-as-a-service (IaaS) and platform-as-a-service (PaaS) offerings. However, configuration on these platforms can be difficult to set up and will usually still require backend developers to set up and maintain.\\n\\nHosting platforms like Netlify, Vercel, as well as headless CMS platforms like Kuroco, can make this process much easier and include a lot of the desired \u2018serverless\u2019 functionality most developers need out-of-the-box.\\n\\n## Kuroco, the Enterprise Headless CMS, comes with serverless architecture built right in:\\n\\nKuroco is a headless CMS that comes with all the serverless functionality you need for focusing on frontend development. For frontend developers, we provide a powerful API management tool that can connect with virtually any backend systems your enterprise has available - and serve up the data you need to be consumed on the client-side.\\n\\nFor content creators and marketers on your team, our headless CMS allows content to be created and published with ease, to any front end interfaces your app is facing.\\n\\n## Related Articles\\n\\n* [Jamstack and Serverless](/blog/jamstack-and-serverless)"},{"id":"waf","metadata":{"permalink":"/blog/waf","source":"@site/blog/waf.md","title":"WAF","description":"A brief introduction to Web Application Firewall","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":2.945,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"WAF","description":"A brief introduction to Web Application Firewall","slug":"waf","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"Serverless","permalink":"/blog/serverless"},"nextItem":{"title":"What Are the Benefits of a Headless CMS?","permalink":"/blog/what-are-the-benefits-of-a-headless-cms"}},"content":"A brief introduction to Web Application Firewall\\n\\n\x3c!-- truncate --\x3e\\n\\n## Overview\\n\\nA web application firewall (or WAF) is a high-level layer in your software that filters the traffic between your web application and the Internet. It mainly serves to protect your app from HTTP attacks like DDoS, XSS (cross-site-scripting), SQL injection, and others. Combined with other security layers in the stack, WAF is an important part of keeping your web app secure.\\n\\nIn the same manner that a proxy server protects the client by serving as an intermediary between the client app and the Internet, a WAF is a reverse proxy that protects the server from any client-side attacks. The WAF filters out any malicious client-side code before it can reach the server to cause any problems.\\n\\n## How Does a WAF Work?\\n\\nA WAF controls outside access to a web application. Malicious requests are denied, as is any outgoing activity that is caused by such malicious activity on the servers.\\n\\nWhen deployed as a reverse proxy, clients must first pass through the WAF (at the \'edge)\' before they can communicate with the origin server. Clients are not typically aware they are communicating with a reverse-proxy instead of directly with the origin server, and the user experience is not negatively impacted in any way.\\n\\nBoth incoming requests from clients and outgoing responses from the origin server are filtered by the WAF before the communications are allowed to pass through. Any attempts on either side that do not pass the WAF\'s security policies are denied.\\n\\n## What are the Main Types of WAF Policies?\\n\\n- Blacklist (aka \u2018block-list\u2019) policies: Protect against known threats that currently exist, while allowing all other traffic through.\\n- Whitelist (aka \u2018allow-list\u2019) policies: Assume all traffic is a threat, unless specifically given permission beforehand.\\n\\nAs both of these approaches have strengths and weaknesses, it is often advisable to combine them to obtain the best desired effect. For example, a site that only has a certain type of desired traffic might set up a whitelist, blocking out all other traffic (while still having a basic blacklist of any malicious requests that may come from any of the whitelisted sources), while some sites may have a wide variety of traffic and depend more on a heavy-handed blacklist approach.\\n\\n## What are the Main Ways a WAF Can be Implemented?\\n\\n- Local/Hardware-based Network: The traditional method used by companies, requiring a local network be set up. This option is the most expensive, requiring large purchases of equipment and expenses to store and maintain the local network.\\n- Hosted: The WAF layer can be hosted in the web application\u2019s software, on the server side. While this method is cheaper in upfront costs to implement, it consumes server resources and requires backend developer resources to set up and maintain.\\n- Cloud-based: The most modern, turn-key solution for implementing WAF. A cloud provider will set up and host all the WAF resources remotely, allowing customers to to purchase access, typically requiring only a simple change in DNS settings to re-route the traffic. Similar to other software-as-a-service (SaaS) solutions, the user is typically charged a monthly or pay-as-you-go fee, treating the service as a utility. Aside from being the cheapest and most convenient option in most cases, the main advantage to this option is that cloud-based providers maintain the WAF on their end, ensuring it is up-to-date for maximum security and reliability.\\n\\nContact us to learn more about Kuroco\u2019s easy-to-use cloud-based WAF solution.\\n\\n## Related Articles\\n\\n* [What is a Reverse Proxy?](/blog/what-is-a-reverse-proxy)"},{"id":"what-are-the-benefits-of-a-headless-cms","metadata":{"permalink":"/blog/what-are-the-benefits-of-a-headless-cms","source":"@site/blog/what-are-the-benefits-of-a-headless-cms.md","title":"What Are the Benefits of a Headless CMS?","description":"A description of the benefits of a headless CMS","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":4.355,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"What Are the Benefits of a Headless CMS?","description":"A description of the benefits of a headless CMS","slug":"what-are-the-benefits-of-a-headless-cms","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"WAF","permalink":"/blog/waf"},"nextItem":{"title":"What is the Backend to Frontend Pattern?","permalink":"/blog/what-is-the-backend-to-frontend-design-pattern"}},"content":"A description of the benefits of a headless CMS\\n\\n\x3c!-- truncate --\x3e\\n\\n<img src=\\"/files/user/img/blog/Kuroco_Headless_Overview.svg\\" alt=\\"serverless functions\\"/>\\n\\nA headless CMS is an updated version of the traditional CMS platforms that have been used in web development for decades.  As with a lot of hype around newer technologies, you may be wondering \\"is this really something I need to pay attention to\\"?  The simple answer is: yes, headless CMSs really do offer a lot of great improvements over their predecessors.\\n\\nWhile we wouldn\'t usually recommend making disruptive changes to your current technology stack if it\'s working  well as is, the changing nature of the web and the trend toward omnichannel marketing is forcing many enterprises to re-evaluate their strategies around managing their content.\\n\\nHere are a few ways that transitioning to a headless CMS can benefit your business:\\n\\n## Provide Data Across Multiple Channels\\n\\nDigital marketing is no longer limited to just the desktop web browser.  As the \u201cInternet of Things\u201d becomes more of a reality, marketers need to be able to deliver content to a wide range of digital touchpoints, including mobile and other devices.\\n\\nDifferent developer teams will likely be working on each of these different frontends.  Trying to handle all these frontends with data that is tightly coupled between a single frontend and the backend of a monolithic CMS can be problematic, to say the least.\\n\\nA headless CMS easily solves this problem, by making data available via an API that can be consumed by all frontend teams independently.\\n\\n## Better Developer Experience\\n\\nAs we have discussed in another entry, frontend teams are often expected to iterate and create constant UI/UX improvements that meet users\u2019 needs, while backend teams focus more on keeping services reliable and secure, and cannot always accommodate frontend requests in a timely manner, within coupled systems architectures.\\n\\nFor example, a UI change could be built out in a couple of weeks, but require breaking changes on the backend that could take months (or even years) to deliver.  These delays can be painful and put a serious damper on productivity.\\n\\nA headless CMS allows the frontend team to work with standard REST APIs to power their UI, and do not depend on backend systems constantly being rebuilt.  This makes both frontend and backend teams much more productive, and gives them the ability to focus on what matters for achieving their respective goals.\\n\\n## Cost Effective, Reduced Overhead\\n\\nAs a result of frontend and backend teams being freed up to focus on their own goals, much less time and resources need to be devoted to system maintenance and putting out fires that arise from having overly complex systems dependencies and the inevitable bugs that crop up as a result.  \\n\\nBackend teams can devote their time to making lasting, impactful changes to systems, rather than fighting against the tide of ever-increasing technical debt.\\n\\nFrontend teams can spend their time building out amazing user interfaces and features that meet the end users\' needs, and simply pull any data they need from the REST API provided by the headless CMS.\\n\\n## Long Term Investment\\n\\nIntegrating with a headless CMS for enterprises typically requires a degree of upfront effort from backend engineers to implement and test, but once it is setup it will pay dividends for the foreseeable future.  A headless CMS architecture is essentially a future-proof tool by its very nature, as APIs make drastic backend restructuring unnecessary - and the frontends that consume that data can be built with any framework the client prefers.\\n\\nIn short: as long as the data exists and is available to be consumed, APIs will be the method of choice for all frontends.\\n\\n## Highly Scalable\\n\\nDue to the nature of APIs and cloud-based infrastructure, a headless CMS is inherently highly scalable.  Nearly all headless CMSs are integrated with content delivery networks (CDNs), which can push your content data to clients around the world, at scale.  Therefore, any frontend channel capable of consuming a REST API can gain access to your enterprise\u2019s content with ease.\\n\\n## More Secure\\n\\nCompared to many traditional web-based CMS platforms, like WordPress, Headless CMSs offer a higher degree of security, due to the separation of concerns.  Many articles have been written in recent years about the security vulnerabilities of these older platforms.\\n\\n## Kuroco Has API Management Functionality Built-In\\n\\nNot all headless CMSs come with API management features out-of-the-box, particularly when it comes to customization of your APIs endpoints on a granular level, and being able to track the analytics of your API usage.\\n\\nKuroco, the enterprise headless CMS, has these features built in and offers a powerful interface for customizing your REST API endpoints in nearly any way you choose.  This interface is available within Kuroco\'s CMS administration panel and allows developers to configure their content APIs with a degree of customization not available in competing platforms.\\n\\nKuroco allows you to configure your API with different paths containing different microservice endpoints for each frontend you have.  This method is similar to the \'backend for frontend\' pattern, and provides a very similar solution.\\n\\nYou can get started today and test it out for free, or feel free to [reach out to our customer support team](https://kuroco.app/docs/about/support/) if you have any questions!"},{"id":"what-is-the-backend-to-frontend-design-pattern","metadata":{"permalink":"/blog/what-is-the-backend-to-frontend-design-pattern","source":"@site/blog/what-is-the-backend-to-frontend-design-pattern.md","title":"What is the Backend to Frontend Pattern?","description":"A description of the backend for frontend microservices pattern","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":2.35,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"What is the Backend to Frontend Pattern?","description":"A description of the backend for frontend microservices pattern","slug":"what-is-the-backend-to-frontend-design-pattern","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"What Are the Benefits of a Headless CMS?","permalink":"/blog/what-are-the-benefits-of-a-headless-cms"},"nextItem":{"title":"Why is a Headless CMS Important for Enterprises?","permalink":"/blog/why-is-a-headless-cms-important-for-enterprises"}},"content":"A description of the backend for frontend microservices pattern\\n\\n\x3c!-- truncate --\x3e\\n\\n## Overview\\n\\nBackend for Frontend (BFF) is essentially an orchestration layer in your development stack, which comprises multiple API Gateways for your application. Similar to a [single API Gateway](/blog/api-gateway-vs-backend-for-frontend), this layer handles a lot of the complexity of fetching and handling microservices data, so that it can be more easily, reliably, and securely consumed by the frontend.\\n\\nWhat makes BFF unique, is that each frontend will have its own dedicated API gateway custom tailoring the data that it receives, instead of having all the frontend channels sharing the same single gateway.\\n\\n## Why BFF is Beneficial\\n\\nThe frontend in modern development increasingly comprises a variety of different devices like web browsers, mobile apps, and other smart devices like televisions, watches, etc.  It is no longer sufficient for your app to only work seamlessly on a web browser - users expect a seamless experience across all their devices.\\n\\nIn order for developers, marketers, and content creators to optimize this experience across all the users\' touch points, the frontend channels must all be connected properly to the backend.\\n\\nIn the past, frontend code was often tightly coupled with the backend, as with traditional monolithic CMS platforms like WordPress and Drupal.  More recently, microservices have come to be widely used.  BFF brings microservices together into a more manageable layer that handles the different data dependencies and requirements in such a way that frontend developers can easily consume the data they need without having to worry about how the API is functioning behind the scenes.\\n\\n### How the BFF Pattern Fits into Kuroco\'s Development Philosophy\\nLike a *kuroco* (or \u2018backstage helper\u2019 in traditional Japanese theater, working behind the scenes to ensure the show runs smoothly), the purpose of a BFF is to consolidate all the data sources of an app into a kind of \u2018black box\u2019 approach that makes the API strategy much more manageable.  This is especially true in the case of large enterprises, where many different microservices being consumed by all frontend channels can become unwieldy to work with.\\n\\n## Kuroco is the Headless CMS Built with API Management in Mind\\n\\nKuroco is a feature-rich headless CMS that enables enterprise teams to easily configure and customize API endpoints.  While we offer a single API gateway out-of-the-box, it can be easily customized to function as a BFF.  This enables you to access all your enterprise\'s data with ease, without having to make complicated, potentially breaking changes to your backend architecture or do expensive rebuilds.\\n\\nKuroco is the best solution of its type for enterprises looking to decouple their backend and frontend concerns.  If you are interested in learning more about how our solutions can help your business, please [contact us](https://kuroco.app/docs/about/support/) and we will be happy to answer any questions you have."},{"id":"why-is-a-headless-cms-important-for-enterprises","metadata":{"permalink":"/blog/why-is-a-headless-cms-important-for-enterprises","source":"@site/blog/why-is-a-headless-cms-important-for-enterprises.md","title":"Why is a Headless CMS Important for Enterprises?","description":"A headless CMS can benefit organizations of various sizes, but how can it benefit enterprises specifically?","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[],"readingTime":3.775,"hasTruncateMarker":true,"authors":[{"name":"Diverta","title":"Creator of Kuroco service","url":"https://www.diverta.co.jp","imageURL":"https://github.com/diverta.png","key":"diverta"}],"frontMatter":{"date":"2022-04-08T00:00:00.000Z","title":"Why is a Headless CMS Important for Enterprises?","description":"A headless CMS can benefit organizations of various sizes, but how can it benefit enterprises specifically?","slug":"why-is-a-headless-cms-important-for-enterprises","authors":"diverta","hide_table_of_contents":false},"prevItem":{"title":"What is the Backend to Frontend Pattern?","permalink":"/blog/what-is-the-backend-to-frontend-design-pattern"}},"content":"A headless CMS can benefit organizations of various sizes, but how can it benefit enterprises specifically?\\n\\n\x3c!-- truncate --\x3e\\n\\n<img src=\\"/files/user/img/blog/Kuroco_Guide_To_Headless_CMS.jpg\\" alt=\\"Headless CMS\\"/>\\n\\n## Table of Contents\\n* Overview\\n* Enterprise Systems Renewal\\n* API Powered Content\\n* Security and Compliance\\n* Not Just for Marketing...\\n\\n## Overview\\n\\nYou may have recently heard the term [\'Headless CMS\'](/blog/headless-cms), one of the latest trends in software development.  The key concept is separating the frontend from backend, which is becoming increasingly important as apps and websites are expected to work seamlessly across multiple platforms, media, and on many devices.\\n\\nTo achieve this, enterprises are moving more towards [microservices architecture](/blog/common-patterns-for-microservices/).  Most enterprises already keep a lot of data, but in legacy systems this data is often locked away in silos, or within the applications it is stored.\\n\\nUnlocking this data is a key use case for adopting a headless CMS, provided the headless CMS is able to function as an [orchestration layer](/blog/api-management), or API gateway.\\n\\nIntegrating with a headless CMS can therefore result in large gains in productivity for enterprises seeking digital transformation and renewal of their legacy systems.  This applies to medium to large corporations and government agencies alike.  \\n\\nHere are a few ways that integrating a headless CMS can benefit enterprises:\\n\\n## Enterprise Systems Renewal\\n\\nMany enterprise systems were built decades ago and follow rigid structures that prevent easy or effective integration with outside systems, hampering data collection and the ability to gather accurate business intelligence.  Integrations with older systems can be costly, and result in resources being wasted on maintenance overhead.\\n\\nIn addition, having siloed systems operating independently of each other can slow overall productivity.  Teams working within silos may have methodologies incompatible with those used on other teams.\\n\\nAn enterprise headless CMS can help companies to open up their legacy systems using APIs.  In most cases is not necessary to rebuild the older systems - it is sufficient to add an orchestration or API gateway layer on top of it, that can communicate with outside clients.\\n\\n## API Powered Content\\n\\nThe most meaningful way that enterprises can improve their systems is by simply making their data more readily available to the different channels that need it.  Legacy data comes in many different formats and protocols, but once it is transformed into standardized REST API data, it is free to be shared and consumed anywhere.\\n\\nAn effective enterprise headless CMS will integrate with your legacy systems, while providing a no-code (or low-code) interface for non-technical content creator users to interact with.\\n\\n## Security and Compliance\\n\\nAn effective enterprise headless CMS will also have functionality built in to control for roles-based permissions.  In large organizations, this is especially important, to allow administrators to define user-level access to those who need it in a timely, and secure manner.\\n\\nThe headless CMS will also have built-in authorization and authentication functionality for requesting data from the client.  The CMS will be securely hosted on the cloud and adhere to best practices for backend security.\\n\\n## Not Just for Marketing...\\n\\nAn important point to keep in mind is that a headless CMS is not just for content creators working on blogs or marketing landing pages etc.  While these are certainly among the best use cases for using a headless CMS in general, enterprises can benefit tremendously from making their internal data more readily available within their own organization.\\n\\nInternal company documentation sites are a clear example of how internal data can be transformed into valuable content.  Taking siloed data and making it transparent for outside teams to view and understand can greatly improve cross-functional collaboration among teams, generate new ideas, and increase productivity.\\n\\nWhether your enterprise\'s data is being used externally or internally, a headless CMS is a powerful tool to manage this data and open it up for secure omnichannel usage.\\n\\n## Kuroco, the Enterprise Headless CMS\\n\\nIf the above benefits are of interest to your enterprise, we hope you\'ll give Kuroco a try!  Our headless CMS is built with enterprises and robust API management in mind.  Our platform is one of the best in the market for integrating with older legacy systems, allowing you to open up your data without having to rebuild your older systems from scratch.  We offer powerful API customization features out of the box, and an easy to use headless CMS interface for both technical and non-technical users.\\n\\nYou can get started today and test it out for free, or feel free to [reach out to our customer support team](https://kuroco.app/docs/about/support/) if you have any questions!"}]}')}}]);